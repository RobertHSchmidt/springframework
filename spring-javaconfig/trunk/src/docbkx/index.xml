<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book xmlns:xi="http://www.w3.org/2001/XInclude">
  <!--
    High-level TODOs (search TODO throughout this document for fine-grained tasks):

    * @Meta (see @Bean.meta()).  No examples/tests; can probably refer to core docs (see A.2.10).
    * @AutoBean (currently in 'undocumented features')
    * ValueSource (and friends)... there is just one very simple unit test;
      need more complete examples. Rod? Perhaps this should go in 'undocumented' as well..
    * @ScopedProxy
    * Bean visibility
    * Fold in contents of m2 docs' Chap 4., "Wire Dependencies"
    * Naming strategy (what section does this belong in?) (see BeanNamingStrategy interface)
    * Figure out formatting for pdf generation (should look like Core Spring PDF).
    * Think about packaging up the 'with-dependencies' jar (for easy downloading from sourceforge)

    Limitations:
    * No property values... enumerate any limitations this imposes
    -->

  <bookinfo>
    <title>Spring JavaConfig Reference Guide</title>

    <releaseinfo>1.0-M3</releaseinfo>

    <authorgroup>
      <author>
        <firstname>Rod</firstname>

        <surname>Johnson</surname>
      </author>

      <author>
        <firstname>Costin</firstname>

        <surname>Leau</surname>
      </author>

      <author>
        <firstname>Chris</firstname>

        <surname>Beams</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Copies of this document may be made for your own use and for
      distribution to others, provided that you do not charge any fee for such
      copies and further provided that each copy contains this Copyright
      Notice, whether distributed in print or electronically.</para>
    </legalnotice>

  </bookinfo>

  <toc />

  <part id="introduction">
    <title>Introduction</title>

    <chapter id="what-is-javaconfig">
      <title>What is JavaConfig?</title>

      <para>Spring JavaConfig is a product of the Spring community that
      provides a pure-Java approach to configuring the Spring IoC Container.
      While JavaConfig aims to be a feature-complete alternative to the more
      well-known XML-based configuration, they can also be used seamlessly
      together. <note>
          <para>See <xref linkend="javaconfig-and-xml" /> for more information
          on using JavaConfig and XML together</para>
        </note></para>
    </chapter>

    <chapter id="why-javaconfig">
      <title>Why JavaConfig?</title>

      <para>The Spring IoC Container is the leading dependency injection
      framework. It provides sophisticated dependency injection capabilities
      as well as advanced features for aspect-oriented programming. Today the
      majority of Spring users configure the Spring container using XML. This
      works very well, and in many cases is ideal. However, some developers
      find configuring the Spring container via Java a more natural or
      appropriate approach, for a variety of reasons.</para>

      <para>Motivations of JavaConfig include</para>

      <formalpara>
        <title>Object-oriented configuration</title>

        <para>Because configurations are defined as classes in JavaConfig,
        users can take full advantage of object-oriented features in Java. One
        configuration class may subclass another, overriding its
        <classname>@Bean</classname> methods, etc.</para>
      </formalpara>

      <formalpara>
        <title>Reduced or eliminated XML configuration</title>

        <para>The benefits of externalized configuration based on the
        principles of dependency injection have been proven. However, many
        developers would prefer not to switch back and forth between XML and
        Java. JavaConfig provides developers with a pure-Java approach to
        configuring the Spring container that is conceptually similar to XML
        configuration. It is technically possible to configure the container
        using only JavaConfig configuration classes, however in practice many
        have found it ideal to mix-and-match JavaConfig with XML. See <xref
        linkend="javaconfig-and-xml" /> for details.</para>
      </formalpara>

      <formalpara>
        <title>Type-safe and refactoring-friendly</title>

        <para>JavaConfig provides a type-safe approach to configuring the
        Spring container. Thanks to Java5's support for generics, it is now
        possible to retrieve beans <emphasis>by type</emphasis> rather than by
        name, free of any casting or string-based lookups. See <xref
        linkend="typesafe-getbean" /> for details.</para>
      </formalpara>
    </chapter>

    <chapter id="requirements">
      <title>Requirements</title>

      <section id="runtime-environment">
        <title>Runtime Environment</title>

        <para>JavaConfig takes full advantage of Java5 language features,
        especially annotations and generics. <emphasis>A Java5+ runtime
        environment is a requirement for using JavaConfig.</emphasis>. For an
        introduction to annotations and other Java5 features, see TODO:
        annotations tutorial</para>
      </section>

      <section id="project-dependencies">
        <title>Project Dependencies</title>

        <para>Every effort has been made to reduce the number of dependencies
        Spring JavaConfig requires. For very simple configurations, the
        dependencies should be limited to CGLIB, commons-logging,
        spring-beans, and spring-context. If you use more advanced features
        such as AOP, you'll need aspectj, spring-aop, etc. Maven2 use is
        recommended, as it helps greatly to reduce the burden of
        dependencies.</para>

        <para>See also: <xref linkend="maven-configs" /></para>
      </section>
    </chapter>

    <chapter id="history">
      <title>History</title>

      <para>JavaConfig was first conceived in 2005, at which time initial code
      was laid down. While it has remained in pre-1.0 status since that time,
      it has enjoyed a fair bit of use and positive user feedback. JavaConfig
      is now a fully supported effort and is moving toward 1.0 release.</para>
    </chapter>

    <chapter id="new-and-noteworthy">
      <title>New &amp; Noteworthy in 1.0-m3</title>

      <section>
        <title><classname>AnnotationApplicationContext</classname>
        deprecated</title>

        <para><classname>AnnotationApplicationContext</classname> presented a
        naming conflict with Spring 2.5's Annotation-Driven Configuration. To
        avoid this problem it has been renamed to
        <classname>JavaConfigApplicationContext</classname>. Beyond the
        renaming, <classname>JavaConfigApplicationContext</classname> has
        several new features worth discussing. See below for details.
        <emphasis><classname>AnnotationApplicationContext</classname> will be removed
        entirely in JavaConfig 1.0-RC1</emphasis></para>

        <para>See <xref linkend="javaconfigapplicationcontext" /></para>
      </section>

      <section>
        <title>Type-safety improvements</title>

        <para><classname>JavaConfigApplicationContext</classname>,
        <classname>JavaConfigWebApplicationContext</classname> and the
        <classname>ConfigurationSupport</classname> base class now all expose
        type-safe <methodname>getBean</methodname> methods, allowing for
        looking up beans by type, rather than by name. <programlisting>
@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

    @Bean
    public NotificationService notificationService() {
        return new NotificationServiceImpl();
    }
}

public class SimpleApp {
    public static void main(String... args) {
        JavaConfigApplicationContext context = new JavaConfigApplicationContext(AppConfig.class);

        // use the type-safe getBean method to avoid casting and string-based lookups
        TransferService transferService = context.getBean(TransferService.class);
        TransferService notificationService = context.getBean(NotificationService.class);

        // ...
    }
}
</programlisting> See <xref linkend="typesafe-getbean" /> for details.</para>
      </section>

      <section>
        <title>First-class support for JavaConfig in the web tier</title>

        <para>By popular demand, a
        <interfacename>WebApplicationContext</interfacename> variant of
        <classname>JavaConfigApplicationContext</classname> has been created.
        This allows for seamless bootstrapping of JavaConfig bean definitions
        within web.xml. Used in conjunction with JavaConfig-specific
        subclasses of <classname>DispatcherServlet</classname> and
        <classname>ContextLoaderListener</classname>, it makes for concise
        usage: <programlisting>
&lt;web-app&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;example.RootApplicationConfig&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.config.java.context.support.JavaConfigContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;test&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.config.java.context.support.JavaConfigDispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;example.web.WebApplicationConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
&lt;/web-app&gt;
</programlisting> For basic information regarding initialization parameters to
        <classname>DispatcherServlet</classname> and use of
        <classname>ContextLoaderListener</classname>, see <ulink
        linkend="http://static.springframework.org/spring/docs/2.5.x/reference/mvc.html">Chapter
        13. Web MVC framework</ulink> in the Core Spring Framework
        documentation.</para>

        <para>For complete details on using JavaConfig in the web tier, see
        <xref linkend="developing-web-applications" />.</para>
      </section>

      <section>
        <title>New semantics for nested <classname>@Configuration</classname>
        classes</title>

        <para>Consider the case of nested
        <classname>@Configuration</classname> classes: <programlisting>
@Configuration
public class OuterConfig {
    @Bean
    public Foo outerBean() {
        // ...
    }

    @Configuration
    public static class InnerConfig {
        @Bean
        public Bar innerBean() {
            // ...
        }
    }
</programlisting> In previous milestones, any nested
        <classname>@Configuration</classname> classes (such as
        <classname>InnerConfig</classname> above) were treated as just another
        source of bean definitions and were processed inline with the rest of
        the beans in the declaring <classname>@Configuration</classname>
        class. Ultimately, all bean definitions ended up in the same
        <classname>BeanFactory</classname>/<classname>ApplicationContext</classname>.</para>

        <para>Now and going forward, nested
        <classname>@Configuration</classname> classes will be processed as
        child <classname>ApplicationContext</classname>s. Perhaps better said,
        any declaring (outer) <classname>@Configuration</classname> classes
        will be processed as parent
        <interfacename>ApplicationContexts</interfacename>. Using the example
        above, Instantiate an
        <interfacename>ApplicationContext</interfacename> using
        <classname>InnerConfig</classname> as an argument <programlisting>
JavaConfigApplicationContext context = new JavaConfigApplicationContext(InnerConfig.class);
context.getBean("innerBean"); // locally defined beans are available
context.getBean("outerBean"); // as are beans defined in the declaring OuterConfig class.
</programlisting> Note that when supplying <classname>OuterConfig</classname>
        as the argument, <classname>InnerConfig</classname> is ignored
        entirely. If it were to be processed, it would become a child context,
        but its beans would would be inaccessible (parent contexts have no
        access to child context beans). <programlisting>
JavaConfigApplicationContext context = new JavaConfigApplicationContext(OuterConfig.class);
context.getBean("outerBean"); // works fine.
context.getBean("innerBean"); // throws NoSuchBeanDefinitionException!
</programlisting></para>

        <para>See <xref linkend="nested-configuration-classes" /> for full
        details.</para>
      </section>

      <section>
        <title>Modularization improvements with
        <classname>@Import</classname></title>

        <para>JavaConfig now has the equivalent of XML configuration's
        <code>&lt;import/&gt;</code> element. One configuration class can
        import any number of other configuration classes, and their bean
        definitions will be processed as if locally defined. <programlisting>
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(...);
    }
}

@Configuration
@Import(DataSourceConfig.class)
public class AppConfig extends ConfigurationSupport {
    @Bean
    public void TransferService transferService() {
        return new TransferServiceImpl(getBean(DataSource.class);
    }
}
</programlisting>Importing multiple configurations can be done by supplying an
        array of classes to the <classname>@Import</classname> annotation
        <programlisting>
@Configuration
@Import({ DataSourceConfig.class, TransactionConfig.class })
public class AppConfig extends ConfigurationSupport {
    // bean definitions can reference bean definitions in DataSourceConfig or TransactionConfig.class
}
</programlisting></para>

        <para>See <xref linkend="importing-configurations" /> for full
        details.</para>
      </section>

      <section>
        <title>Support for externalizing string values with
        <classname>@ExternalValue</classname></title>

        <para>Somewhat similar to the way that
        <classname>@ExternalBean</classname> makes it possible to reference
        beans defined outside of the current
        <classname>@Configuration</classname>,
        <classname>@ExternalBean</classname> allows for accessing externalized
        string values in properties files. This is ideal for use when
        configuring up infrastructural resources with properties that may
        change at deployment time, or otherwise need to be externally
        accessible for modification. <programlisting>
@Configuration
@ResourceBundles("com/myapp/datasource")
public abstract class AppConfig {
    @Bean
    public DataSource myDataSource() {
        DataSource dataSource = new MyDataSource();
        dataSource.setUsername(username());
        dataSource.setPassword(password());
        dataSource.setUrl(url());

        return dataSource;
    }

    @ExternalValue
    public abstract String username();

    @ExternalValue
    public abstract String password();

    @ExternalValue("jdbc.url")
    public abstract String url();
}
</programlisting> com/myapp/datasource.properties: <programlisting>
username=scott
password=tiger
jdbc.url=...
</programlisting> See <xref linkend="externalizing-string-values" /> for full
        details</para>
      </section>
    </chapter>

    <chapter id="quick-start">
      <title>Quick Start</title>

      <chapterinfo>
        <abstract>
          <para>This chapter provides a basic tutorial for getting started
          with JavaConfig. For full details on JavaConfig's capabilities,
          please refer to <xref linkend="reference" /></para>
        </abstract>
      </chapterinfo>

      <section>
        <title>Download JavaConfig</title>

        <section>
          <title>Maven 2</title>

          <para>Assuming a Maven2 build infrastructure, using JavaConfig is as
          simple as adding the following to your POM <programlisting>
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.javaconfig&lt;/groupId&gt;
        &lt;artifactId&gt;spring-javaconfig&lt;/artifactId&gt;
        &lt;version&gt;1.0-m3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</programlisting> <note> See <xref linkend="maven-configs" /> for more
          information about using Maven2 with Spring JavaConfig </note></para>
        </section>

        <section>
          <title>Ant/Other</title>

          <para>TODO: Download from sourceforge (link), consider the
          -with-dependencies jar.</para>
        </section>
      </section>

      <section>
        <title>Create Bean Definitions</title>

        <para>
          <programlisting>
@Configuration
public class ApplicationConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource());
    }

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(TODO: args);
    }
}
</programlisting>
        </para>
      </section>

      <section>
        <title>Retrieve Bean Instances</title>

        <para>Let's create a very basic, command-line application to allow
        users to transfer money from one account to another. <programlisting>
public class SimpleTransferApplication {
    public static void main(String... args) {
        double amount = new Double(args[0]);
        int sourceAcctId = new Integer(args[1]);
        int destAcctId = new Integer(args[2]);

        JavaConfigApplicationContext context = new JavaConfigApplicationContext(ApplicationConfig.class);
        TransferService transferService = context.getBean(TransferService.class);
        transferService.transfer(300.00, sourceAcctId, destAccountId);
    }
}
</programlisting></para>
      </section>

      <section>
        <title>Summary</title>

        <para>Obviously, we're a bit too simplistic here, to learn more about
        modularizing <classname>@Configuration</classname> classes, see TODO link. To learn about
        more advanced mechanisms for ... TODO continue this approach,</para>
      </section>
    </chapter>
  </part>

  <part id="reference">
    <title>API Reference</title>

    <partintro>
      <title>Document Structure</title>

      <para>This part of the Reference Guide explains the core functionality
      of Spring JavaConfig</para>

      <para><xref linkend="creating-bean-definitions" /> describes the
      fundamental concepts in Spring JavaConfig: the <classname>@Configuration</classname> and <classname>@Bean</classname>
      annotations, and gives the reader information on how to use them.</para>

      <para><xref linkend="modularity" />. For non-trivial uses of Spring
      JavaConfig, users will want the ability to modularize configurations for
      reuse, readability and deployment concerns. This section documents the
      various techniques and features available for meeting these
      needs.</para>

      <para><xref linkend="aop" />. One of the most powerful features of the
      Spring IoC container is the ability to add aspect-oriented behavior to
      plain beans using Spring AOP. JavaConfig also makes the use of aspects
      possible, and this section details how to do it.</para>

      <para><xref linkend="developing-web-applications" />. Documents
      JavaConfig's first-class support for use within the web tier with
      <classname>JavaConfigWebApplicationContext</classname>, along with
      convenient subclasses of Spring MVC's
      <classname>DispatcherServlet</classname> and
      <classname>ContextLoaderListener</classname>.</para>

      <para><xref linkend="combining-config-approaches" />. Describes how to
      use JavaConfig's <classname>ConfigurationPostProcessor</classname> bean
      post-processor for integrating
      <classname>@Configuration</classname>-annotated classes within an XML
      configuration file.</para>
    </partintro>

    <chapter id="creating-bean-definitions">
      <title>Creating and using bean definitions</title>

      <section>
        <title><classname>@Configuration</classname></title>

        <para>Annotating a class with the
        <classname>@Configuration</classname> annotation indicates that the
        class will be used by JavaConfig as a source of bean definitions.</para>

        <para>An application may make use of just one <classname>@Configuration</classname>-annotated
        class, or many. <classname>@Configuration</classname> can be
        considered the equivalent of XML's <code>&lt;beans/&gt;</code>
        element. Like <code>&lt;beans/&gt;</code>, it provides an opportunity
        to explicitly set defaults for all enclosed bean definitions.
        <programlisting>
@Configuration(defaultAutowire = Autowire.BY_TYPE, defaultLazy = Lazy.FALSE)
public class DataSourceConfiguration extends ConfigurationSupport {
    // bean definitions follow
}
</programlisting> Because the semantics of the attributes to the
        <classname>@Configuration</classname> annotation are 1:1 with the
        attributes to the <code>&lt;beans/&gt;</code> element, this documentation defers to
        the section in Chapter 3, IoC from the core spring documentation. See
        <ulink linkend="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-definition">http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-definition</ulink></para>
      </section>

      <section id="bean">
        <title>
          <classname>@Bean</classname>
        </title>

        <para><classname>@Bean</classname> is a direct analog to XML
        configuration's <code>&lt;bean/&gt;</code> element. As such, it accepts a set as
        annotation attributes equivalent to the attributes to the
        <code>&lt;bean/&gt;</code>. See TODO: link to core spring framework documentation
        on bean and its attributes.</para>

        <section id="declaring-a-bean">
          <title>Declaring a bean</title>

          <para>To declare a bean, simply annotate a method with the
          <classname>@Bean</classname> annotation.</para>

          <programlisting>
@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
</programlisting>
        </section>

        <section id="bean-visibility">
          <title>Bean visibility</title>

          <para>TODO</para>
        </section>
      </section>

      <section id="javaconfigapplicationcontext">
        <title><classname>JavaConfigApplicationContext</classname></title>

        <para><classname>JavaConfigApplicationContext</classname> provides
        direct access to the beans defined by
        <classname>@Configuration</classname>-annotated classes. For more
        information on the ApplicationContext API in general, please refer to
        the Core Spring documentation. TODO: link to core spring framework
        documentation on ApplicationContext</para>

        <section id="construction-options">
          <title>Construction Options</title>

          <para>Instantiating the
          <classname>JavaConfigApplicationContext</classname> be done by
          supplying <classname>@Configuration</classname>-annotated class
          literals to the constructor, and/or strings representing packages to
          scan for <classname>@Configuration</classname>-annotated
          classes.</para>

          <section>
            <title>Construction by class literal</title>

            <para>Each of the class literals supplied to the constructor will
            be processed, and for each <classname>@Bean</classname>-annotated
            method encountered, JavaConfig will create a bean definition and
            ultimately instantiate and initialize the bean.</para>

            <programlisting>
JavaConfigApplicationContext context =
    new JavaConfigApplicationContext(AppConfig.class);
Service service = (Service) context.getBean("serviceA");
</programlisting>

            <programlisting>
JavaConfigApplicationContext context =
    new JavaConfigApplicationContext(AppConfig.class, DataConfig.class);
Service service = (Service) context.getBean("serviceA");
</programlisting>
          </section>

          <section>
            <title>Construction by base package</title>

            <para>Base packages will be scanned for the existence of any
            <classname>@Configuration</classname>-annotated classes. Any
            candidate classes will then be processed much as if they had been
            supplied directly as class literals to the constructor.</para>

            <programlisting>
JavaConfigApplicationContext context =
    new JavaConfigApplicationContext("**/configuration/**/*.class");
Service service = (Service) context.getBean("serviceA");
</programlisting>

            <programlisting>
JavaConfigApplicationContext context =
    new JavaConfigApplicationContext("**/configuration/**/*.class", "**/other/*Config.class);
Service service = (Service) context.getBean("serviceA");
</programlisting>
          </section>

          <section>
            <title>Post-construction configuration</title>

            <para>When one or more classes/packages are used during
            construction, a
            <classname>JavaConfigApplicationContext</classname> cannot be
            further configured. If post-construction configuration is
            preferred or required, use either the no-arg constructor,
            configure by calling setters, then manually refresh the context.
            After the call to <methodname>refresh()</methodname>, the context
            will be 'closed for configuration'.</para>

            <programlisting>
JavaConfigApplicationContext context = new JavaConfigApplicationContext();
context.setParent(otherConfig);
context.setConfigClasses(AppConfig.class, DataConfig.class);
context.setBasePackages("**/configuration/**/*.class");
context.refresh();
Service service = (Service) context.getBean("serviceA");
</programlisting>
          </section>
        </section>

        <note>
          <para>Whenever multiple packages and/or classes are used to
          instantiate a <classname>JavaConfigApplicationContext</classname>,
          <emphasis>order matters</emphasis>. This is important when
          considering what happens if two configuration classes define a bean
          with the same name. The last-specified class wins.</para>
        </note>

        <section id="typesafe-getbean">
          <title>Type-safe access to beans</title>

          <para>One of the criticisms of the Spring approach to dependency
          injection is that direct access to beans via an ApplicationContext
          depends on fragile string-based lookups and requires casting. This
          has been mitigated by the fact that looking up beans via the
          <classname>ApplicationContext</classname> API is comparatively
          rarely done, but nevertheless, the argument stands.</para>

          <para>JavaConfig helps address this complaint by offering users a
          type-safe mechanism for looking up beans via the
          <classname>JavaConfigApplicationContext</classname>:
          <programlisting>
JavaConfigApplicationContext context = new JavaConfigApplicationContext(...);
Service service = context.getBean(Service.class);
</programlisting></para>
        </section>
      </section>
    </chapter>

    <chapter id="modularity">
      <title>Modularizing configurations</title>

      <chapterinfo>
        <abstract>
          <para>While the simplest configuration may be expressed as a single
          class that exposes several beans, it is often desirable to
          <emphasis>modularize</emphasis> configurations for reuse and
          clarity.</para>
        </abstract>
      </chapterinfo>

      <section>
        <title>Referencing externally defined beans</title>

        <para>One configuration class may need to reference a bean defined in
        another configuration class (or in XML, for that matter). The
        <classname>@ExternalBean</classname> annotation provides just such a
        mechanism. When JavaConfig encounters a method annotated as
        <classname>@ExternalBean</classname>, it replaces that method
        definition with a lookup to the enclosing bean factory for a bean with
        the same name as the method name.</para>

        <programlisting>
@Configuration
public class ConfigOne {
    @Bean
    public AccountRepository accountRepository() {
        // create and return an AccountRepository object
       }
}

@Configuration
public abstract class ConfigTwo {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository());
    }

    @ExternalBean
    public abstract AccountRepository accountRepository();
}
</programlisting>

        <para>Given that both these configuration classes are supplied to the
        application context at runtime, JavaConfig will be able to resolve the
        '<literal>accountRepository</literal>'
        <classname>@ExternalBean</classname> by name and everything will
        'wire-up' accordingly.</para>

        <programlisting>
JavaConfigApplicationContext context = new JavaConfigApplicationContext(ConfigOne.class, ConfigTwo.class);
</programlisting>
      </section>

      <section id="externalizing-string-values">
        <title>Working with externalized string values</title>

        <sidebar>
          <title>What about
          <classname>PropertyOverrideConfigurer</classname>?</title>

          <para>Those familiar with XML configuration will notice that there
          is not a direct equivalent for the popular
          <classname>PropertyOverrideConfigurer</classname>. However, the
          combination of <classname>@ResourceBundles</classname> and
          <classname>@ExternalValue</classname> is roughly equivalent to the
          use of the <classname>PropertyPlaceholderConfigurer</classname>.
          Just as many users do not wish to store usernames, passwords and
          other sensitive or environment-specific values in XML, neither would
          we want to do so in Java configurations. Interestingly, the
          functionality of <classname>PropertyOverrideConfigurer</classname>
          is not hard to emulate, either. Simply give the method a default
          return value.</para>

          <para>
            <emphasis>TODO (chris): this last bit is yet another reason why
            @ExternalValue should be a field-level annotation, rathor than the
            awkward 'abstract method' approach. Giving a field a default value
            is very natural for Java programmers. Indeed, a much more natural
            concept than having to learn about <classname>BeanFactoryPostProcessor</classname>s, and
            what Proprty(Placeholder|Override)Configurer are all
            about.</emphasis>
          </para>
        </sidebar>

        <para>Access externally defined string values such as usernames,
        passwords, and the like using <classname>@ResourceBundles</classname>
        and <classname>@ExternalValue</classname>.</para>

        <programlisting>
@ResourceBundles("org/springframework/config/java/simple")
@Configuration
public abstract static class ConfigWithPlaceholders {
    @ExternalValue("datasource.username")
    public abstract String username();

    @Bean
    public TestBean testBean() {
        return new TestBean(username());
    }
}
</programlisting>

        <para>The '<literal>org/springframework/config/java/simple</literal>'
        argument to <classname>@ResourceBundles</classname> tells JavaConfig
        that there must be a file in the classpath at
        <literal>org/springframework/config/java/simple[locale].[properties|xml]</literal>
        from which key/value pairs can be read. For example:</para>

        <programlisting>
datasource.username=scott
datasource.password=tiger
...
</programlisting>

        <para>Multiple values can be supplied to
        <classname>@ResourceBundles</classname>:</para>

        <programlisting>
@ResourceBundles({"com/foo/myapp/simple", "com/foo/myapp/complex"})
@Configuration
public class AppConfig {
    // ...
}
</programlisting>
      </section>

      <section id="importing-configurations">
        <title>Importing configurations</title>

        <para>Much like the XML <code>&lt;import/&gt;</code> element, configuration classes
        can now import one another, for an additional tool in the
        modularization toolbox.</para>

        <programlisting>
@Configuration
@Import(OtherConfig.class)
public class MyConfig {
}
</programlisting>
      </section>

      <section>
        <title>ConfigurationSupport</title>

        <para>As a convenience, <classname>@Configuration</classname> classses
        can extend <classname>ConfigurationSupport</classname>, primarily in
        order to facilitate easy lookup of beans from the enclosing
        <classname>BeanFactory</classname> / <classname>ApplicationContext</classname>.</para>

        <programlisting>
@Configuration
public class AppConfig extends ConfigurationSupport {
    @Bean
    public Service serviceA() {
        DataSource dataSource = (DataSource) this.getBean("dataSource"); // provided by base class
        // ...
    }
}
</programlisting>
      </section>

      <section id="nested-configuration-classes"><title>Nesting
      <classname>@Configuration</classname> classes</title> TODO (see new
      &amp; noteworthy...)</section>
    </chapter>

    <chapter id="aop">
      <title>Using aspects</title>

      <chapterinfo>
        <abstract>
          <para>AOP support in JavaConfig is a work-in-progress. It is
          documented here in order to solicit feedback.</para>
        </abstract>
      </chapterinfo>

      <para>Spring JavaConfig has full support for AspectJsupports the same
      set of AspectJ annotations used throughout</para>

      <section>
        <title>Embedded aspects</title>

        <para>TODO: link out to an overview of AOP for the
        uninitiatied.</para>

        <para>A configuration class can serve 'double duty' as an aspect. By
        applying <classname>@Aspect</classname> to a <classname>@Configuration</classname> class, you can then add pointcuts
        and advice that will be applied against all beans in the container.
        <programlisting>
@Aspect
@Configuration
public class AppConfig {
    @Bean
    public Service service() {
        return new ServiceImpl(...);
    }

    @Before("execution(* service..Service+.set*(*))")
    public void trackServicePropertyChange() {
        logger.info("property changed on service!");
    }
}
</programlisting> This pointcut will match the all methods starting with 'set'
        on all implementations of the Service interface. Before any matching
        methods execute, the
        <methodname>trackServicePropertyChange()</methodname> method will be
        executed.</para>

        <note>
          <para>It is currently considered somewhat awkward that Configuration
          classes must be annotated with <classname>@Aspect</classname> to enable this functionality.
          This is not consistent with the standard semantics around the
          <classname>@Aspect</classname> annotation, and would thus likely be un-intuitive to someone
          familiar with XML configuration. <emphasis>This may change before
          1.0 GA</emphasis></para>
        </note>
      </section>

      <section>
        <title>Reusable aspects</title>

        <para>To create a reusable aspect, define a class annotated with
        <classname>@Configuration</classname>and <classname>Aspect</classname>containing advice methods and
        pointcuts.</para>

        <programlisting>
@Aspect
@Configuration
public class PropertyChangeTracker {
    private Logger logger = Logger.getLogger(PropertyChangeTracker.class);

    @Before("execution(* set*(*))")
    public void trackChange() {
        logger.info("property just changed...");
    }
}
</programlisting>

        <para>Then include that aspect in the application context, either
        using the @Import annotation or by adding at as a constructor argument
        when instantiating <classname>JavaConfigApplicationContext</classname>. Examples of both
        approaches are below. <note>
            <para>In either case, all configuration classes that wish to have
            their beans be candidates for aspect weaving must also be
            annotated with <classname>@Aspect</classname>. <emphasis>This is clearly non-ideal, and
            will likely change before 1.0 GA.</emphasis></para>
          </note></para>

        <programlisting>
@Configuration
@Import(PropertyChangeTracker.class)
@Aspect // necessary in order to have transferService bean get aspects applied!
public class MyConfig {
    @Bean
    public TransferService myService() {
        return new TransferServiceImpl(...);
    }
}

...

JavaConfigApplicationContext context = new JavaConfigApplicationContext(MyConfig.class);
</programlisting>

        <para>or...</para>

        <programlisting>
@Aspect // necessary in order to have transferService bean get aspects applied!
@Configuration
public class MyConfig {
    @Bean
    public TransferService myService() {
        return new TransferServiceImpl(...);
    }
}

...

JavaConfigApplicationContext context = new JavaConfigApplicationContext(MyConfig.class, PropertyChangeTracker.class);
</programlisting>
      </section>

      <section>
        <title><classname>@HotSwappable</classname></title>

        <para>TODO: Rod</para>
      </section>
    </chapter>

    <chapter id="developing-web-applications">
      <title>Developing JavaConfig-powered web applications</title>

      <chapterinfo>
        <abstract>
          <para>JavaConfig provides several support classes for bootstrapping
          your configurations into the web tier. With various combinations of
          <classname>JavaConfigWebApplicationContext</classname>,
          <classname>JavaConfigDispatcherServlet</classname> and
          <classname>JavaConfigContextLoaderListener</classname>, you can
          achieve XML-free web application configuration.</para>
        </abstract>
      </chapterinfo>

      <section>
        <title><classname>JavaConfigWebApplicationContext</classname></title>

        <para>TODO: Somewhere in here I need to talk about bean naming for
        BeanNameHandlerMapping. Use @Bean(aliases="")?</para>

        <para>TODO: finish section</para>
      </section>
    </chapter>

    <chapter id="combining-config-approaches">
      <title>Combining configuration approaches</title>

      <abstract>
        <para>JavaConfig can be used in conjunction with any or all of
        Spring's other container configuration approaches. The question is
        when and where it's appropriate to do so.</para>
      </abstract>

      <section id="javaconfig-and-xml">
        <title>JavaConfig and XML</title>

        <section>
          <title>Bootstrapping JavaConfig from XML with
          <classname>ConfigurationPostProcessor</classname></title>

          <para>Currently, to use JavaConfig and XML config together, the
          configuration needs to be 'XML-driven', meaning that it will be the
          XML configuration that bootstraps JavaConfig. <programlisting>
&lt;beans&gt;
   &lt;!-- first, define your individual @Configuration classes as beans --&gt;
   &lt;bean class="com.myapp.config.AppConfig"/&gt;
   &lt;bean class="com.myapp.config.DataConfig"/&gt;

    &lt;!-- be sure to include the JavaConfig bean post-processor --&gt;
    &lt;bean class="org.springframework.config.java.process.ConfigurationPostProcessor"/&gt;
&lt;/beans&gt;
</programlisting> Then, bootstrap an XML ApplicationContext: <programlisting>ApplicationContext context = new ClassPathXmlApplicationContext("application-config.xml");</programlisting>
          The beans defined in <classname>AppConfig</classname> and
          <classname>DataConfig</classname> will be available via
          '<varname>context</varname>'.</para>

          <section id="configuring-configurations">
            <title>Configuring configurations</title>

            <para>An added benefit that comes along with bootstrapping
            JavaConfig from XML is that the configuration bean instances are
            eligible, just as any other bean, for configuration:
            <programlisting>
&lt;beans&gt;
    &lt;!-- a possible configurable configuration --&gt;
    &lt;bean class="org.my.company.config.AppConfiguration"&gt;
        &lt;property name="env" value="TESTING"/&gt;
        &lt;property name="monitoring" value="true"/&gt;
        &lt;property name="certificates" value="classpath:/META-INF/config/MyCompany.certs"/&gt;
    &lt;/bean&gt;
    &lt;!-- Java Configuration post processor --&gt;
    &lt;bean class="org.springframework.config.java.process.ConfigurationPostProcessor"/&gt;
&lt;/beans&gt;
</programlisting></para>
          </section>
        </section>

        <section>
          <title>Best Practices</title>

          <para>
            <emphasis>TODO: talk about when it's best to use a combination of
            XML and JavaConfig Mention limitations like lack of osgi:, tx:,
            aop:, context: namespaces (or link to <xref
            linkend="limitations" />)</emphasis>
          </para>
        </section>
      </section>

      <section>
        <title>JavaConfig and Annotation-Driven Configuration</title>

        <para>TODO</para>
      </section>
    </chapter>
  </part>

  <part id="appendices">
    <title>Appendices</title>
      <appendix id="limitations">
        <title>Limitations</title>

        <para>Compare SJC against XML / ADC, describing any functionality that is
        currently not supported. * bean names can only be legal java method names.
        Workaround == @Bean(aliases="/whatev, foo^bar")? Possibly introduce
        improvement issue for adding a @Bean(name=...</para>

        <para>no ability to do constructor autowiring (basic limitation of
        Java)</para>

        <para>Nesting <classname>@Configuration</classname> classes. When nesting <classname>@Configuration</classname> classes
        (either inside one another, or inside non-<classname>@Configuration</classname> classes)
        <classname>@Configuration</classname> classes cannot be defined as local inner classes (classes
        defined inside methods), they must be static and non-private. This is due
        to CGLIB limitations.</para>

        <para>talk about namespace support in xml</para>
      </appendix>

      <appendix id="undocumented-features">
        <title>Undocumented Features</title>

        <para>There are a number of classes, interfaces and annotations within the
        public JavaConfig API that remain undocumented. This is intentional, as
        they may be deprecated and/or removed before the 1.0 GA release. They
        include <orderedlist>
            <listitem>
              <para><classname>@AutoBean</classname></para>
            </listitem>

            <listitem>
              <para><classname>@SpringAdvice</classname></para>
            </listitem>

            <listitem>
              <para><classname>@SpringAdvisor</classname></para>
            </listitem>
          </orderedlist></para>
      </appendix>

      <appendix id="roadmap">
        <title>Roadmap</title>

        <para>SJC has been a work in progress for some time now. To the benefit of
        the project, this means that there has been a long period of user feedback
        and experience before a GA release. Of course, the downside of this is
        that there's no GA release suitable for use in production. In the process
        of putting together the M3 release, it has become clear that there are
        several key aspects of JavaConfig that deserve re-thinking and re-working.
        It is important that we get the JavaConfig programming model 'as right as
        possible' before the 1.0 release, because after that we will be bound by
        backward compatibility forever (or at least until 2.0). For this reason,
        the team is not rushing a 1.0 release 'out the door'. There is more work
        to do, and it may result in another milestone before beginning the release
        candidate process for 1.0. Things that work for you now may break very
        shortly. What we need most is your feedback! Please try out the new
        features listed in <xref linkend="new-and-noteworthy" /> and let us know
        what you think!</para>

        <para>See the <ulink
        linkend="http://jira.springframework.org/browse/SJC?report=com.atlassian.jira.plugin.system.project:roadmap-panel">JavaConfig
        JIRA roadmap</ulink> for up-to date information</para>
      </appendix>

      <appendix id="tooling">
        <title>Visualizing Configurations with Spring IDE</title>

        <para>Spring IDE http://springide.org supports JavaConfig. At the time of
        this writing, however, support is limited to configurations that are
        'bootstrapped' via XML (see <xref linkend="javaconfig-and-xml" />). Follow
        (link to Spring IDE jira) for updates on progress here. TODO: Do a
        screenshot here</para>
      </appendix>

      <appendix id="additional-resources">
        <title>Additional Resources</title>

        <section><title>Core Spring Documentation</title> The Core Spring
        documentation is mentioned throughout this document, and it is recommended
        that JavaConfig users read and understand the TODO: link: IoC reference.
        Although it discusses XML, its treatment of fundamental concepts remains
        directly applicable to JavaConfig</section>

        <section><title>Community Forum</title> The first place to stop with
        questions around SJC is <ulink
        linkend="http://forums.springframework.org" />. As of this writing, Spring
        JavaConfig does not have its own dedicated forum, but you can post
        questions to TODO: which forum?</section>

        <section id="issue-tracking"><title>Issue Tracking</title> After checking
        out the forums, any bugs, improvements or new features can be submitted
        via the Spring Framework issue tracker at <ulink
        linkend="http://jira.springframework.org/browse/SJC" /></section>

        <section><title>SpringSource Team Blog</title> Keep up to date with
        JavaConfig progress by watching the SpringSource Team Blog at <ulink
        linkend="http://blog.springsource.com" /></section>

        <section><title>Consulting and Training Services</title> SpringSource
        specializes in consulting and training services for Spring, including
        Spring JavaConfig. TODO: list email.</section>
      </appendix>

      <appendix id="common-configuration-scenarios">
        <title>Common configuration scenarios</title>

        <para>For easy reference, a few commonly-used configurations</para>

        <section>
          <title>Declarative Transaction Management</title>

          <para>TODO</para>
        </section>

        <section>
          <title>Externalized DataSource information</title>

          <para>TODO</para>
        </section>
      </appendix>

      <appendix id="how-javaconfig-works">
        <title>How JavaConfig works</title>

        <para>What are the internal mechanisms by which JavaConfig works?</para>

        <section><title>Dynamic subclassing of
        <classname>@Configuration</classname>-annotated classes with CGLIB</title>
        TODO: ...</section>
      </appendix>

      <appendix id="maven-configs">
        <title>Maven2 POM Configurations</title>

        <appendixinfo>Maven provides nice trans dep mgmt, but... here are some
        configs to help ease this process.</appendixinfo>

        <para>As mentioned in TODO link: Quick Start, JavaConfig requires only a
        minimal set of dependencies for the most basic configuration
        scenarios.</para>

        <section>
          <title>Minimalist</title>

          <para>
            <programlisting>
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.javaconfig&lt;/groupId&gt;
        &lt;artifactId&gt;spring-javaconfig&lt;/artifactId&gt;
        &lt;version&gt;1.0-m3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
    </programlisting>
          </para>
        </section>

        <section>
          <title>AOP</title>

          <para>
            <programlisting>
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.javaconfig&lt;/groupId&gt;
        &lt;artifactId&gt;spring-javaconfig&lt;/artifactId&gt;
        &lt;version&gt;1.0-m3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aopalliance&lt;/groupId&gt;
        &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;asm&lt;/groupId&gt;
        &lt;artifactId&gt;asm&lt;/artifactId&gt;
        &lt;version&gt;2.2.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;asm&lt;/groupId&gt;
        &lt;artifactId&gt;asm-commons&lt;/artifactId&gt;
        &lt;version&gt;2.2.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjlib&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
    </programlisting>
          </para>
        </section>
      </appendix>
    </part>
</book>
