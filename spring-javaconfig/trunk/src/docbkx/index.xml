<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book xmlns:xi="http://www.w3.org/2001/XInclude">
  <bookinfo>
    <title>Spring JavaConfig Reference Guide</title>

    <releaseinfo>1.0-M3</releaseinfo>

    <authorgroup>
      <author>
        <firstname>Rod</firstname>

        <surname>Johnson</surname>
      </author>

      <author>
        <firstname>Costin</firstname>

        <surname>Leau</surname>
      </author>

      <author>
        <firstname>Chris</firstname>

        <surname>Beams</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Copies of this document may be made for your own use and for
      distribution to others, provided that you do not charge any fee for such
      copies and further provided that each copy contains this Copyright
      Notice, whether distributed in print or electronically.</para>
    </legalnotice>
  </bookinfo>

  <toc />

  <part id="introduction">
    <title>Introduction</title>

    <chapter id="what-is-javaconfig">
      <title>What is JavaConfig?</title>

      <para>Spring JavaConfig is a product of the Spring community that
      provides a pure-Java approach to configuring the Spring IoC Container.
      While JavaConfig aims to be a feature-complete alternative to the more
      well-known XML-based configuration, they can also be used seamlessly
      together. <note>
          <para>See <xref linkend="javaconfig-and-xml" /> for more information
          on using JavaConfig and XML together</para>
        </note></para>
        </chapter>

    <chapter id="why-javaconfig">
        <title>Why JavaConfig?</title>

        <para>The Spring IoC Container is the leading dependency injection
        framework. It provides</para>

        <para>Motivations of JavaConfig include</para>

        <formalpara>
          <title>XML-free dependency injection.</title>

          <para>The benefits of externalized configuration based on the
          principles of dependency injection have been proven. However, many
          developers would prefer not to switch back and forth between XML and
          Java. JavaConfig provides developers with a pure-Java approach to
          configuring the Spring container that is conceptually similar to XML
          configuration.</para>
        </formalpara>

        <formalpara>
          <title>Type-safe and refactoring-friendly</title>

          <para>JavaConfig provides a 100% type-safe approach to configuring
          the Spring container. Thanks to Java5's support for generics, it is
          now possible to retrieve beans <emphasis>by type</emphasis> rather
          than by name, free of any casting or string-based lookups. See <xref
          linkend="type-safe-getbean" /> for full details.</para>
        </formalpara>
      </chapter>

      <chapter id="requirements">
        <title>Requirements</title>

        <para>JavaConfig takes full advantage of Java5 language features,
        especially annotations and generics. <emphasis>A Java5+ runtime
        environment is a requirement for using JavaConfig.</emphasis></para>

        <para>Every effort has been made to reduce the number of dependencies
        Spring JavaConfig requires. For very simple configurations, the
        dependencies should be limited to CGLIB, commons-logging,
        spring-beans, and spring-context. If you use more advanced features
        such as AOP, you'll need aspectj, spring-aop, etc. Maven2 use is
        recommended, as it helps greatly to reduce the burden of
        dependencies.</para>

      </chapter>

      <chapter>
        <title>History</title>

        <para>JavaConfig was first conceived in 2005, at which time initial
        code was laid down. While it has remained in pre-1.0 status since that
        time, it has enjoyed a fair bit of use and positive user feedback.
        JavaConfig is now a fully supported effort and is moving toward 1.0
        release.</para>
      </chapter>

    <chapter>
      <title>New &amp; Noteworthy in 1.0-m3</title>

      <section>
        <title><classname>AnnotationApplicationContext</classname>
        deprecated</title>

        <para><classname>AnnotationApplicationContext</classname> presented a
        naming conflict with Spring 2.5's Annotation-Driven Configuration. To
        avoid this problem entirely, it has been renamed to
        <classname>JavaConfigApplicationContext</classname>. Beyond the
        renaming, <classname>JavaConfigApplicationContext</classname> has
        several new features worth discussing. See below for details.
        <classname>AnnotationApplicationContext</classname> will be removed
        entirely in JavaConfig 1.0-RC1</para>
      </section>

      <section>
        <title>Type-safety improvements</title>

        <para><classname>JavaConfigApplicationContext</classname>,
        <classname>JavaConfigWebApplicationContext</classname> and the
        <classname>ConfigurationSupport</classname> base class now all expose
        type-safe <methodname>getBean</methodname> methods, allowing for
        looking up beans by type, rather than by name. <programlisting>@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

    @Bean
    public NotificationService notificationService() {
        return new NotificationServiceImpl();
    }
}

public class SimpleApp {
    public static void main(String... args) {
        JavaConfigApplicationContext context = new JavaConfigApplicationContext(AppConfig.class);

        // use the type-safe getBean method to avoid casting and string-based lookups
        TransferService transferService = context.getBean(TransferService.class);
        TransferService notificationService = context.getBean(NotificationService.class);

        // ...
    }
}</programlisting> See <xref linkend="typesafe-getbean" /> for details.</para>
      </section>

      <section>
        <title>First-class support for JavaConfig in the web tier</title>

        <para>By popular demand, a
        <interfacename>WebApplicationContext</interfacename> variant of
        <classname>JavaConfigApplicationContext</classname> has been created.
        This allows for seamless bootstrapping of JavaConfig bean definitions
        within web.xml. Used in conjunction with JavaConfig-specific
        subclasses of <classname>DispatcherServlet</classname> and
        <classname>ContextLoaderListener</classname>, it makes for concise
        usage: <programlisting>&lt;web-app&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;example.RootApplicationConfig&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.config.java.context.support.JavaConfigContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;test&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.config.java.context.support.JavaConfigDispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;example.web.WebApplicationConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
&lt;/web-app&gt;</programlisting> For basic information regarding
        initialization parameters to <classname>DispatcherServlet</classname>
        and use of <classname>ContextLoaderListener</classname>, see <ulink
        linkend="http://static.springframework.org/spring/docs/2.5.x/reference/mvc.html">Chapter
        13. Web MVC framework</ulink> in the Core Spring Framework
        documentation.</para>
      </section>

      <section>
        <title>Improved support for nested
        <classname>@Configuration</classname> classes</title>

        <para>Consider the case of nested
        <classname>@Configuration</classname> classes: <programlisting>@Configuration
public class Outer {
    @Bean
    public Foo outerBean() {
        // ...
    }

    @Configuration
    public static class InnerConfig {
        @Bean
        public Bar innerBean() {
            // ...
        }
    }
</programlisting> In previous milestones, any nested
        <classname>@Configuration</classname> classes (such as
        <classname>InnerConfig</classname> above) were treated as just another
        source of bean definitions and were processed inline with the rest of
        the beans in the declaring @Configuration class. Ultimately, all bean
        definitions ended up in the same
        BeanFactory/ApplicationContext.</para>

        <para>Now and going forward, nested
        <classname>@Configuration</classname> classes will be processed as
        child <classname>ApplicationContext</classname>s. Perhaps better said,
        any declaring (outer) <classname>@Configuration</classname> classes
        will be processed as parent
        <interfacename>ApplicationContexts</interfacename>. Using the example
        above, Instantiate an
        <interfacename>ApplicationContext</interfacename> using
        <classname>InnerConfig</classname> as an argument <programlisting>@Configuration
JavaConfigApplicationContext context = new JavaConfigApplicationContext(InnerConfig.class);
context.getBean("innerBean"); // locally defined beans are available
context.getBean("outerBean"); // as are beans defined in the declaring OuterConfig class.
}</programlisting> Note that when supplying <classname>OuterConfig</classname>
        as the argument, <classname>InnerConfig</classname> is ignored
        entirely. If it were to be processed, it would become a child context,
        but its beans would would be inaccessible (parent contexts have no
        access to child context beans). <programlisting>@Configuration
JavaConfigApplicationContext context = new JavaConfigApplicationContext(OuterConfig.class);
context.getBean("outerBean"); // works fine.
context.getBean("innerBean"); // throws NoSuchBeanDefinitionException!
}</programlisting></para>
      </section>

      <section>
        <title>Modularization improvements with
        <classname>@Import</classname></title>

        <para>JavaConfig now has the equivalent of XML configuration's
        <code>&lt;import/&gt;</code> element. One configuration class can
        import any number of other configuration classes, and their bean
        definitions will be processed as if locally defined. <programlisting>@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(...);
    }
}

@Import(DataSourceConfig.class)
@Configuration
public class AppConfig extends ConfigurationSupport {
    @Bean
    public void TransferService transferService() {
        return new TransferServiceImpl(getBean(DataSource.class);
    }
}
</programlisting> Importing multiple configurations can be done by supplying
        an array of classes to the <classname>@Import</classname> annotation
        <programlisting>@Import({ DataSourceConfig.class, TransactionConfig.class })
@Configuration
public class AppConfig extends ConfigurationSupport {
    // bean definitions can reference bean definitions in DataSourceConfig or TransactionConfig.class
}
</programlisting></para>
      </section>

      <section>
        <title>
          <classname>@ValueSource</classname>
        </title>

        <para>TODO: Rod?</para>
      </section>
    </chapter>

    <chapter id="quick-start">
      <title>Quick Start</title>

      <chapterinfo>
        <abstract><para>This chapter provides a basic tutorial for getting started
        with JavaConfig. For full details on JavaConfig's capabilities, please
        refer to <xref linkend="reference" /></para></abstract>
      </chapterinfo>

      <section>
        <title>Download JavaConfig</title>

        <section>
          <title>Maven 2</title>

          <para>Assuming a Maven2 build infrastructure, using JavaConfig is as
          simple as adding the following to your POM <programlisting>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.javaconfig&lt;/groupId&gt;
        &lt;artifactId&gt;spring-javaconfig&lt;/artifactId&gt;
        &lt;version&gt;1.0-m3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting> <note> See <xref
          linkend="maven-configs" /> for more information about using Maven2
          with Spring JavaConfig </note></para>
        </section>

        <section>
          <title>Ant/Other</title>

          <para>TODO: Download from sourceforge (link), consider the
          -with-dependencies jar.</para>
        </section>
      </section>

      <section>
        <title>Create Bean Definitions</title>

        <para>
          <programlisting>@Configuration
public class ApplicationConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource());
    }

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(TODO: args);
    }
}</programlisting>
        </para>
      </section>

      <section>
        <title>Retrieve Bean Instances</title>

        <para>Let's create a very basic, command-line application to allow
        users to transfer money from one account to another. <programlisting>public class SimpleTransferApplication {
    public static void main(String... args) {
        double amount = new Double(args[0]);
        int sourceAcctId = new Integer(args[1]);
        int destAcctId = new Integer(args[2]);

        JavaConfigApplicationContext context = new JavaConfigApplicationContext(ApplicationConfig.class);
        TransferService transferService = context.getBean(TransferService.class);
        transferService.transfer(300.00, sourceAcctId, destAccountId);
    }
}</programlisting></para>
      </section>

      <section>
        <title>Summary</title>

        <para>Obviously, we're a bit too simplistic here, to learn more about
        modularizing @Configuration classes, see TODO link. To learn about
        more advanced mechanisms for ... TODO continue this approach,</para>
      </section>
    </chapter>
  </part>

  <part id="reference">
    <title>API Reference</title>

    <chapter id="basics">
      <title>Basics - Configurations, Beans and instantiating the
      JavaConfigApplicationContext</title>

      <section>
        <title>@Configuration</title>

        <para>Annotating a class with the
        <classname>@Configuration</classname> annotation indicates that the
        class will be used as a source of bean definitions. <programlisting>@Configuration
public class AppConfig {
    // bean definitions follow
}</programlisting></para>

        <para><classname>@Configuration</classname> can be considered the
        equivalent of XML's <code>&lt;beans/&gt;</code> element. It provides
        an opportunity to explicitly set defaults for all enclosed bean
        definitions. <programlisting>
@Configuration(defaultAutowire = Autowire.BY_TYPE, defaultLazy = Lazy.FALSE)
public class DataSourceConfiguration
extends ConfigurationSupport {
}</programlisting> It can be considered the equivalent of
        <code>&lt;beans/&gt;</code> tag. It is advisable that classes with
        @Configuration annotation extend the ConfigurationSupport as it offers
        several utility methods. It also provides an opportunity to override
        various default values for all enclosed bean definitions.
        <programlisting>@Configuration()
public class AppConfig {
    // bean definitions follow
}</programlisting>
        http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-definition</para>
      </section>

      <section>
        <title>@Bean</title>

        <para />
      </section>

      <section>
        <title>@Bean</title>

        <para />
      </section>
    </chapter>

    <chapter id="modularity">
      <title>Techniques for Modularization and Reuse of JavaConfig
      classes</title>

      <chapterinfo>
        <abstract>
          <para>While the simplest configuration may be expressed as a single
          class that exposes several beans, it is often desirable to
          <emphasis>modularize</emphasis> configurations for reuse and
          clarity.</para>
        </abstract>
      </chapterinfo>

      <section><title>@ExternalBean</title> Keeping configurations
      clean...</section>

      <section><title>ConfigurationSupport</title> Keeping configurations
      clean...</section>

      <section><title>ValueSource</title> Keeping configurations
      clean...</section>
    </chapter>

    <chapter id="aop">
      <title>Aspect-Oriented Programming Support</title>

      <chapterinfo>
        <abstract>
          <para>One of the key features of the Spring IoC container is AOP...
          Of course, Spring JavaConfig supports this fully. It can do
          everything that XML config can do.</para>
        </abstract>
      </chapterinfo>

      <section>
        <title>@SpringAdvice</title>
      </section>

      <section>
        <title>@SpringAdvisor</title>
      </section>

      <section>
        <title>@Aspect</title>
      </section>

      <section>
        <title>@HotSwappable</title>
      </section>
    </chapter>

    <chapter id="javaconfig-applicationcontexts">
      <title>JavaConfig <interfacename>ApplicationContext</interfacename>
      implementations</title>

      <chapterinfo>
        <abstract>
          <para>Like any approach to configuring the Spring Container, access
          to beans happens through an implementation of Spring's
          ApplicationContext interface. Spring JavaConfig provides two
          implementations, one for ...</para>
        </abstract>
      </chapterinfo>

      <section>
        <title>JavaConfigApplicationContext</title>
      </section>

      <section><title>JavaConfigWebApplicationContext</title> Somewhere in
      here I need to talk about bean naming for BeanNameHandlerMapping. Use
      @Bean(aliases="")?</section>
    </chapter>
  </part>

  <appendix id="limitations">
    <title>Limitations</title>

    <para>Compare SJC against XML / ADC, describing any functionality that is
    currently not supported. * bean names can only be legal java method names.
    Workaround == @Bean(aliases="/whatev, foo^bar")? Possibly introduce
    improvement issue for adding a @Bean(name=...</para>

    <para>no ability to do constructor autowiring (basic limitation of
    Java)</para>

    <para>Nesting @Configuration classes. When nesting @Configuration classes
    (either inside one another, or inside non-@Configuration classes)
    @Configuration classes cannot be defined as local inner classes (classes
    defined inside methods), they must be static and non-private. This is due
    to CGLIB limitations.</para>

    <para>talk about namespace support in xml</para>
  </appendix>

  <appendix id="roadmap">
    <title>Roadmap</title>

    <para>This documentation covers SJC M3, which will be the last milestone
    before initiating the release process. SJC is feature-frozen for the 1.0
    release, and the team hopes that this final milestone and all its ...
    solicit bugs</para>

    <para>see JIRA for up-to date roadmap information</para>
  </appendix>

  <appendix id="tooling">
    <title>Visualizing Configurations with Spring IDE</title>

    <para>Spring IDE http://springide.org supports JavaConfig. At the time of
    this writing, however, support is limited to configurations that are
    'bootstrapped' via XML. Follow (link to Spring IDE jira) for updates on
    progress here. TODO: Do a screenshot here</para>
  </appendix>

  <appendix id="additional-resources">
    <title>Additional Resources</title>

    <appendixinfo />

    <section><title>Core Spring Documentation</title> The Core Spring
    documentation is mentioned throughout this document, and it is recommended
    that JavaConfig users read and understand the TODO: link: IoC reference.
    Although it discusses XML, its treatment of fundamental concepts is every
    bit as true for JavaConfig</section>

    <section><title>Community Forum</title> The first place to stop with
    questions around SJC is http://forums.springframework.org. As of this
    writing, Spring JavaConfig does not have its own dedicated forum, but you
    can post questions to TODO: which forum?</section>

    <section><title>Issue Tracking</title> After checking out the forums, any
    new features jira/SJC How to submit a bug:</section>

    <section><title>SpringSource Team Blog</title> Keep up to date with
    JavaConfig progress by watching the SpringSource Team Blog</section>

    <section><title>Consulting and Training Services</title> SpringSource
    specializes in consulting and training services for Spring, including
    Spring JavaConfig. TODO: list email.</section>
  </appendix>

  <appendix id="maven-configs">
    <title>Maven2 POM Configurations</title>

    <appendixinfo>Maven provides nice trans dep mgmt, but... here are some
    configs to help ease this process.</appendixinfo>

    <para>As mentioned in TODO link: Quick Start, JavaConfig requires only a
    minimal set of dependencies for the most basic configuration
    scenarios.</para>

    <section>
      <title>Minimalist</title>

      <para>
        <programlisting>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.javaconfig&lt;/groupId&gt;
        &lt;artifactId&gt;spring-javaconfig&lt;/artifactId&gt;
        &lt;version&gt;1.0-m3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
      </para>
    </section>

    <section>
      <title>AOP</title>

      <para>
        <programlisting>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.javaconfig&lt;/groupId&gt;
        &lt;artifactId&gt;spring-javaconfig&lt;/artifactId&gt;
        &lt;version&gt;1.0-m3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aopalliance&lt;/groupId&gt;
        &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;asm&lt;/groupId&gt;
        &lt;artifactId&gt;asm&lt;/artifactId&gt;
        &lt;version&gt;2.2.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;asm&lt;/groupId&gt;
        &lt;artifactId&gt;asm-commons&lt;/artifactId&gt;
        &lt;version&gt;2.2.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjlib&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
      </para>
    </section>
  </appendix>
</book>