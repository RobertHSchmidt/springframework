<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"
[
<!ENTITY about-this-document          SYSTEM "about-this-document.xml">
<!ENTITY overview                     SYSTEM "overview.xml">
<!ENTITY new-and-noteworthy           SYSTEM "new-and-noteworthy.xml">
<!ENTITY quick-start                  SYSTEM "quick-start.xml">
<!ENTITY creating-bean-definitions    SYSTEM "creating-bean-definitions.xml">
<!ENTITY modularizing-configurations  SYSTEM "modularizing-configurations.xml">
]>
<book xmlns:xi="http://www.w3.org/2001/XInclude">
  <!--
    High-level TODOs (search TODO throughout this document for fine-grained tasks):

    * [formatting]: abstracts are not the way to go.  they render huge, and they're not consistent
                    with core spring documentation.  yank them out, figure out a better way.
    * @Meta (see @Bean.meta()).  No examples/tests; can probably refer to core docs (see A.2.10).
    * @AutoBean (currently in 'undocumented features')
    * ValueSource (and friends)... there is just one very simple unit test;
      need more complete examples. Rod? Perhaps this should go in 'undocumented' as well..
    * @ScopedProxy
    * Bean visibility
    * Fold in contents of m2 docs' Chap 4., "Wire Dependencies"
    * Naming strategy (what section does this belong in?) (see BeanNamingStrategy interface)
    * Figure out formatting for pdf generation (should look like Core Spring PDF).
    * Think about packaging up the 'with-dependencies' jar (for easy downloading from sourceforge)

    Limitations:
    * No property values... enumerate any limitations this imposes
  -->

  <bookinfo>
    <title>Spring JavaConfig Reference Guide</title>
    <releaseinfo>1.0-M3</releaseinfo>
    <authorgroup>
      <author>
        <firstname>Rod</firstname>
        <surname>Johnson</surname>
      </author>
      <author>
        <firstname>Costin</firstname>
        <surname>Leau</surname>
      </author>
      <author>
        <firstname>Chris</firstname>
        <surname>Beams</surname>
      </author>
    </authorgroup>
    <legalnotice>
      <para>Copies of this document may be made for your own use and for
      distribution to others, provided that you do not charge any fee for such
      copies and further provided that each copy contains this Copyright
      Notice, whether distributed in print or electronically.</para>
    </legalnotice>
  </bookinfo>

  <toc />

  &about-this-document;

  <part id="introduction">
    <title>Introduction</title>
    <partintro>
      <para>In Part I we explain what JavaConfig is, how it fits into the
      larger Spring configuration landscape, and make the case as to why it is
      a compelling alternative. After reading this part you'll be ready to
      create a basic configuration and evaluate JavaConfig for yourself.
      Finally, you'll be ready to move on to Part II and explore the
      JavaConfig API in detail.</para>
      <para><xref linkend="overview" /></para>
      <para><xref linkend="new-and-noteworthy" /></para>
      <para><xref linkend="quick-start" /></para>
    </partintro>
    &overview;
    &new-and-noteworthy;
    &quick-start;
  </part>

  <part id="reference">
    <title>API Reference</title>
    <partintro>
      <para>This part of the Reference Guide explains the core functionality
      of Spring JavaConfig</para>

      <para><xref linkend="creating-bean-definitions" /> describes the
      fundamental concepts in Spring JavaConfig: the
      <classname>@Configuration</classname> and <classname>@Bean</classname>
      annotations, and gives the reader information on how to use them.</para>

      <para><xref linkend="modularizing-configurations" />. For non-trivial uses
      of Spring JavaConfig, users will want the ability to modularize
      configurations for reuse, readability and deployment concerns. This
      section documents the various techniques and features available for
      meeting these needs.</para>

      <para><xref linkend="aop" />. One of the most powerful features of the
      Spring IoC container is the ability to add aspect-oriented behavior to
      plain beans using Spring AOP. JavaConfig also makes the use of aspects
      possible, and this section details how to do it.</para>

      <para><xref linkend="developing-web-applications" />. Documents
      JavaConfig's first-class support for use within the web tier with
      <classname>JavaConfigWebApplicationContext</classname>, along with
      convenient subclasses of Spring MVC's
      <classname>DispatcherServlet</classname> and
      <classname>ContextLoaderListener</classname>.</para>

      <para><xref linkend="combining-config-approaches" />. Describes how to
      use JavaConfig's <classname>ConfigurationPostProcessor</classname> bean
      post-processor for integrating
      <classname>@Configuration</classname>-annotated classes within an XML
      configuration file.</para>
    </partintro>
    &creating-bean-definitions;
    &modularizing-configurations;
    <chapter id="aop">
      <title>Using aspects</title>

      <chapterinfo>
        <abstract>
          <para>AOP support in JavaConfig is a work-in-progress. It is
          documented here in order to solicit feedback.</para>
        </abstract>
      </chapterinfo>

      <para>Spring JavaConfig has full support for AspectJsupports the same
      set of AspectJ annotations used throughout</para>

      <section>
        <title>Embedded aspects</title>

        <para>TODO: link out to an overview of AOP for the
        uninitiatied.</para>

        <para>A configuration class can serve 'double duty' as an aspect. By
        applying <classname>@Aspect</classname> to a
        <classname>@Configuration</classname> class, you can then add
        pointcuts and advice that will be applied against all beans in the
        container. <programlisting>@Aspect
@Configuration
public class AppConfig {
    @Bean
    public Service service() {
        return new ServiceImpl(...);
    }

    @Before("execution(* service..Service+.set*(*))")
    public void trackServicePropertyChange() {
        logger.info("property changed on service!");
    }
}
</programlisting> This pointcut will match the all methods starting with 'set'
        on all implementations of the Service interface. Before any matching
        methods execute, the
        <methodname>trackServicePropertyChange()</methodname> method will be
        executed.</para>

        <note>
          <para>It is currently considered somewhat awkward that Configuration
          classes must be annotated with <classname>@Aspect</classname> to
          enable this functionality. This is not consistent with the standard
          semantics around the <classname>@Aspect</classname> annotation, and
          would thus likely be un-intuitive to someone familiar with XML
          configuration. <emphasis>This may change before 1.0
          GA</emphasis></para>
        </note>
      </section>

      <section>
        <title>Reusable aspects</title>

        <para>To create a reusable aspect, define a class annotated with
        <classname>@Configuration</classname>and
        <classname>Aspect</classname>containing advice methods and
        pointcuts.</para>

        <programlisting>@Aspect
@Configuration
public class PropertyChangeTracker {
    private Logger logger = Logger.getLogger(PropertyChangeTracker.class);

    @Before("execution(* set*(*))")
    public void trackChange() {
        logger.info("property just changed...");
    }
}
</programlisting>

        <para>Then include that aspect in the application context, either
        using the @Import annotation or by adding at as a constructor argument
        when instantiating
        <classname>JavaConfigApplicationContext</classname>. Examples of both
        approaches are below. <note>
            <para>In either case, all configuration classes that wish to have
            their beans be candidates for aspect weaving must also be
            annotated with <classname>@Aspect</classname>. <emphasis>This is
            clearly non-ideal, and will likely change before 1.0
            GA.</emphasis></para>
          </note></para>

        <programlisting>@Configuration
@Import(PropertyChangeTracker.class)
@Aspect <lineannotation>// necessary in order to have <literal>transferService</literal> bean get aspects applied!</lineannotation>
public class MyConfig {
    @Bean
    public TransferService myService() {
        return new TransferServiceImpl(...);
    }
}

...

JavaConfigApplicationContext context = new JavaConfigApplicationContext(MyConfig.class);
</programlisting>

        <para>or...</para>

        <programlisting>@Aspect <lineannotation>// necessary in order to have <literal>transferService</literal> bean get aspects applied!</lineannotation>
@Configuration
public class MyConfig {
    @Bean
    public TransferService myService() {
        return new TransferServiceImpl(...);
    }
}

...

JavaConfigApplicationContext context = new JavaConfigApplicationContext(MyConfig.class, PropertyChangeTracker.class);
</programlisting>
      </section>

      <section>
        <title>
          <classname>@HotSwappable</classname>
        </title>

        <para>TODO: Rod</para>
      </section>
    </chapter>

    <chapter id="developing-web-applications">
      <title>Developing JavaConfig-powered web applications</title>

      <chapterinfo>
        <abstract>
          <para>JavaConfig provides several support classes for bootstrapping
          your configurations into the web tier. With various combinations of
          <classname>JavaConfigWebApplicationContext</classname>,
          <classname>JavaConfigDispatcherServlet</classname> and
          <classname>JavaConfigContextLoaderListener</classname>, you can
          achieve XML-free web application configuration.</para>
        </abstract>
      </chapterinfo>

      <section>
        <title>
          <classname>JavaConfigWebApplicationContext</classname>
        </title>

        <para>TODO: Somewhere in here I need to talk about bean naming for
        BeanNameHandlerMapping. Use @Bean(aliases="")?</para>

        <para>TODO: finish section</para>
      </section>
    </chapter>

    <chapter id="combining-config-approaches">
      <title>Combining configuration approaches</title>

      <abstract>
        <para>JavaConfig can be used in conjunction with any or all of
        Spring's other container configuration approaches. The question is
        when and where it's appropriate to do so.</para>
      </abstract>

      <section id="javaconfig-and-xml">
        <title>JavaConfig and XML</title>

        <section>
          <title>Bootstrapping JavaConfig from XML with
          <classname>ConfigurationPostProcessor</classname></title>

          <para>Currently, to use JavaConfig and XML config together, the
          configuration needs to be 'XML-driven', meaning that it will be the
          XML configuration that bootstraps JavaConfig. <programlisting>&lt;beans&gt;
   <lineannotation>&lt;!-- first, define your individual <classname>@Configuration</classname> classes as beans --&gt;</lineannotation>
   &lt;bean class="com.myapp.config.AppConfig"/&gt;
   &lt;bean class="com.myapp.config.DataConfig"/&gt;

    <lineannotation>&lt;!-- be sure to include the JavaConfig bean post-processor --&gt;</lineannotation>
    &lt;bean class="org.springframework.config.java.process.ConfigurationPostProcessor"/&gt;
&lt;/beans&gt;
</programlisting> Then, bootstrap an XML ApplicationContext: <programlisting>ApplicationContext context = new ClassPathXmlApplicationContext("application-config.xml");</programlisting>
          The beans defined in <classname>AppConfig</classname> and
          <classname>DataConfig</classname> will be available via
          '<varname>context</varname>'.</para>

          <section id="configuring-configurations">
            <title>Configuring configurations</title>

            <para>An added benefit that comes along with bootstrapping
            JavaConfig from XML is that the configuration bean instances are
            eligible, just as any other bean, for configuration:
            <programlisting>&lt;beans&gt;
    <lineannotation>&lt;!-- a possible "configurable configuration" --&gt;</lineannotation>
    &lt;bean class="org.my.company.config.AppConfiguration"&gt;
        &lt;property name="env" value="TESTING"/&gt;
        &lt;property name="monitoring" value="true"/&gt;
        &lt;property name="certificates" value="classpath:/META-INF/config/MyCompany.certs"/&gt;
    &lt;/bean&gt;
    <lineannotation>&lt;!-- JavaConfig post-processor --&gt;</lineannotation>
    &lt;bean class="org.springframework.config.java.process.ConfigurationPostProcessor"/&gt;
&lt;/beans&gt;
</programlisting></para>
          </section>
        </section>

        <section>
          <title>Best Practices</title>

          <para>
            <emphasis>TODO: talk about when it's best to use a combination of
            XML and JavaConfig Mention limitations like lack of osgi:, tx:,
            aop:, context: namespaces (or link to <xref
            linkend="limitations" />)</emphasis>
          </para>
        </section>
      </section>

      <section>
        <title>JavaConfig and Annotation-Driven Configuration</title>

        <para>TODO</para>
      </section>
    </chapter>
  </part>

  <part id="appendices">
    <title>Appendices</title>

    <appendix id="limitations">
      <title>Limitations</title>

      <para>Compare SJC against XML / ADC, describing any functionality that
      is currently not supported. * bean names can only be legal java method
      names. Workaround == @Bean(aliases="/whatev, foo^bar")? Possibly
      introduce improvement issue for adding a @Bean(name=...</para>

      <para>no ability to do constructor autowiring (basic limitation of
      Java)</para>

      <para>Nesting <classname>@Configuration</classname> classes. When
      nesting <classname>@Configuration</classname> classes (either inside one
      another, or inside non-<classname>@Configuration</classname> classes)
      <classname>@Configuration</classname> classes cannot be defined as local
      inner classes (classes defined inside methods), they must be static and
      non-private. This is due to CGLIB limitations.</para>

      <para>talk about namespace support in xml</para>
    </appendix>

    <appendix id="undocumented-features">
      <title>Undocumented Features</title>

      <para>There are a number of classes, interfaces and annotations within
      the public JavaConfig API that remain undocumented. This is intentional,
      as they may be deprecated and/or removed before the 1.0 GA release. They
      include <orderedlist>
          <listitem>
            <para>
              <classname>@AutoBean</classname>
            </para>
          </listitem>

          <listitem>
            <para>
              <classname>@SpringAdvice</classname>
            </para>
          </listitem>

          <listitem>
            <para>
              <classname>@SpringAdvisor</classname>
            </para>
          </listitem>
        </orderedlist></para>
    </appendix>

    <appendix id="roadmap">
      <title>Roadmap</title>

      <para>SJC has been a work in progress for some time now. To the benefit
      of the project, this means that there has been a long period of user
      feedback and experience before a GA release. Of course, the downside of
      this is that there's no GA release suitable for use in production. In
      the process of putting together the M3 release, it has become clear that
      there are several key aspects of JavaConfig that deserve re-thinking and
      re-working. It is important that we get the JavaConfig programming model
      'as right as possible' before the 1.0 release, because after that we
      will be bound by backward compatibility forever (or at least until 2.0).
      For this reason, the team is not rushing a 1.0 release 'out the door'.
      There is more work to do, and it may result in another milestone before
      beginning the release candidate process for 1.0. Things that work for
      you now may break very shortly. What we need most is your feedback!
      Please try out the new features listed in <xref
      linkend="new-and-noteworthy" /> and let us know what you think!</para>

      <para>See the <ulink
      linkend="http://jira.springframework.org/browse/SJC?report=com.atlassian.jira.plugin.system.project:roadmap-panel">JavaConfig
      JIRA roadmap</ulink> for up-to date information</para>
    </appendix>

    <appendix id="tooling">
      <title>Visualizing Configurations with Spring IDE</title>

      <para>Spring IDE http://springide.org supports JavaConfig. At the time
      of this writing, however, support is limited to configurations that are
      'bootstrapped' via XML (see <xref linkend="javaconfig-and-xml" />).
      Follow (link to Spring IDE jira) for updates on progress here. TODO: Do
      a screenshot here</para>
    </appendix>

    <appendix id="common-configuration-scenarios">
      <title>Common configuration scenarios</title>

      <para>For easy reference, a few commonly-used configurations</para>

      <section>
        <title>Declarative Transaction Management</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Externalized DataSource information</title>

        <para>TODO</para>
      </section>
    </appendix>

    <appendix id="how-javaconfig-works">
      <title>How JavaConfig works</title>

      <para>What are the internal mechanisms by which JavaConfig works?</para>

      <section><title>Dynamic subclassing of
      <classname>@Configuration</classname>-annotated classes with
      CGLIB</title> TODO: ...</section>
    </appendix>

    <appendix id="maven-configs">
      <title>Maven2 POM Configurations</title>

      <appendixinfo>Maven provides nice trans dep mgmt, but... here are some
      configs to help ease this process.</appendixinfo>

      <para>As mentioned in TODO link: Quick Start, JavaConfig requires only a
      minimal set of dependencies for the most basic configuration
      scenarios.</para>

      <section>
        <title>Minimalist</title>

        <para>
          <programlisting>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.javaconfig&lt;/groupId&gt;
        &lt;artifactId&gt;spring-javaconfig&lt;/artifactId&gt;
        &lt;version&gt;1.0-m3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
    </programlisting>
        </para>
      </section>

      <section>
        <title>AOP</title>

        <para>
          <programlisting>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.javaconfig&lt;/groupId&gt;
        &lt;artifactId&gt;spring-javaconfig&lt;/artifactId&gt;
        &lt;version&gt;1.0-m3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aopalliance&lt;/groupId&gt;
        &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;asm&lt;/groupId&gt;
        &lt;artifactId&gt;asm&lt;/artifactId&gt;
        &lt;version&gt;2.2.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;asm&lt;/groupId&gt;
        &lt;artifactId&gt;asm-commons&lt;/artifactId&gt;
        &lt;version&gt;2.2.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjlib&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
        </para>
      </section>
    </appendix>

    <appendix id="additional-resources">
      <title>Additional Resources</title>

      <section><title>Core Spring Documentation</title> The Core Spring
      documentation is mentioned throughout this document, and it is
      recommended that JavaConfig users read and understand the TODO: link:
      IoC reference. Although it discusses XML, its treatment of fundamental
      concepts remains directly applicable to JavaConfig</section>

      <section><title>Community Forum</title> The first place to stop with
      questions around SJC is <ulink
      linkend="http://forums.springframework.org" />. As of this writing,
      Spring JavaConfig does not have its own dedicated forum, but you can
      post questions to TODO: which forum?</section>

      <section id="issue-tracking"><title>Issue Tracking</title> After
      checking out the forums, any bugs, improvements or new features can be
      submitted via the Spring Framework issue tracker at <ulink
      linkend="http://jira.springframework.org/browse/SJC" /></section>

      <section><title>SpringSource Team Blog</title> Keep up to date with
      JavaConfig progress by watching the SpringSource Team Blog at <ulink
      linkend="http://blog.springsource.com" /></section>

      <section><title>Consulting and Training Services</title> SpringSource
      specializes in consulting and training services for Spring, including
      Spring JavaConfig. TODO: list email.</section>
    </appendix>
  </part>
</book>
