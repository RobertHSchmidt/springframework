<?xml version="1.0" encoding="UTF-8"?>
<chapter id="creating-bean-definitions">
  <title>Creating and using bean definitions</title>

  <section>
    <title>
      <classname>@Configuration</classname>
    </title>

    <para>Annotating a class with the
    <classname>@Configuration</classname> annotation indicates that the
    class will be used by JavaConfig as a source of bean
    definitions.</para>

    <para>An application may make use of just one
    <classname>@Configuration</classname>-annotated class, or many.
    <classname>@Configuration</classname> can be considered the equivalent
    of XML's <code>&lt;beans/&gt;</code> element. Like
    <code>&lt;beans/&gt;</code>, it provides an opportunity to explicitly
        set defaults for all enclosed bean definitions. <programlisting>@Configuration(defaultAutowire = Autowire.BY_TYPE, defaultLazy = Lazy.FALSE)
public class DataSourceConfiguration extends ConfigurationSupport {
    <lineannotation>// bean definitions follow</lineannotation>
}
</programlisting> Because the semantics of the attributes to the
    <classname>@Configuration</classname> annotation are 1:1 with the
    attributes to the <code>&lt;beans/&gt;</code> element, this
    documentation defers to the
    <ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-definition">
    beans-definition section</ulink>  of Chapter 3, IoC from the Core Spring
    documentation.</para>
  </section>

  <section id="bean">
    <title>
      <classname>@Bean</classname>
    </title>

    <para><classname>@Bean</classname> is a method-level annotation and
    a direct analog the XML <code>&lt;bean/&gt;</code> element.  The annotation
    supports most of the attributes offered by <code>&lt;bean/&gt;</code> such as
    <literal><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-autowire">autowiring</ulink></literal>,
    <literal><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-lazy-init">lazy-init</ulink></literal>,
    <literal><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-dependencies">dependency-check</ulink></literal>,
    <literal><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-dependson">depends-on</ulink></literal>
    and <literal><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-scopes">scoping</ulink></literal>.</para>

    <section id="declaring-a-bean">
      <title>Declaring a bean</title>

      <para>To declare a bean, simply annotate a method with the
      <classname>@Bean</classname> annotation.  When JavaConfig encounters
      such a method, it will execute that method and registers the return value
      as a bean within a <interfacename>BeanFactory</interfacename>.  The bean
      name will be that of the method name.</para>

      <programlisting>@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
</programlisting>

      The above is exactly equivalent to the following <literal>appConfig.xml</literal>:
      <programlisting>&lt;beans&gt;
    &lt;bean name=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;
&lt;/beans&gt;
</programlisting>

      Both will result in a bean named <literal>transferService</literal> being
      available in the <literal>BeanFactory</literal>/<literal>ApplicationContext</literal>,
      bound to an object instance of type <classname>TransferServiceImpl</classname>:
      <programlisting>transferService => com.acme.TransferService</programlisting>
      See <xref linkend="javaconfigapplicationcontext"/> for details about
      instantiating and using an <interfacename>ApplicationContext</interfacename>
      with JavaConfig.
    </section>

    <section id="aware-interfaces">
      <title>Using <literal>*Aware</literal> interfaces</title>

       The standard set of <literal>*Aware</literal> interfaces such as
       <interfacename><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-aware-beanfactoryaware">BeanFactoryAware</ulink></interfacename>,
       <interfacename><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-aware-beannameaware">BeanNameAware</ulink></interfacename>,
       <interfacename><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#context-functionality-messagesource">MessageSourceAware</ulink></interfacename>,
       <interfacename><ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#context-functionality-events">ApplicationContextAware</ulink></interfacename>,
       etc. are fully supported.  Consider an example class that implements
       <interfacename>BeanFactoryAware</interfacename>:

       <programlisting>public class AwareBean implements BeanFactoryAware {

    private BeanFactory factory;

    <lineannotation>// <interfacename>BeanFactoryAware</interfacename> setter (called by Spring during bean instantiation)</lineannotation>
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.factory = beanFactory;
    }

    public void close(){
        <lineannotation>// do clean-up</lineannotation>
    }
}</programlisting>

      <para>Also, the <ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-nature">lifecycle</ulink>
      methods and <code>*Aware</code> interfaces are fully supported:</para>
    </section>

    <section id="bean-visibility">
      <title>Bean visibility</title>
      <para>TODO: flesh out explanation of concepts, add in Rod's diagram</para>
    </section>

    <section id="bean-scoping">
      <title>Bean scoping</title>

      <section id="scoped-proxy">
        <title><classname>@ScopedProxy</classname></title>
        <para>TODO: document <classname>@ScopedProxy</classname></para>
      </section>

      <section id="method-injection-obsolete">
        <title>Method injection</title>
        <para>As noted in the Core documentation,
        <ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-method-injection">method injection</ulink>
        is an advanced topic that should be comparatively rarely used.  When using
        XML configuration, it is required in cases where a singleton-scoped bean has
        a dependency on a prototype-scoped bean.  In JavaConfig, however, it is a
        (somewhat) simpler proposition:</para>

        <programlisting>@Bean
public MyAbstractSingleton mySingleton(){
    return new MyAbstractSingleton(myDependencies()){
        public MyPrototype createMyPrototype(){
            return new MyPrototype(someOtherDependency());
            <lineannotation>// or alternatively return <methodname>myPrototype()</methodname> -- this is some <classname>@Bean</classname> or <classname>@ExtarnalBean</classname> method...</lineannotation>
        }
    }
}</programlisting>
      </section>
    </section>
  </section>



  <section id="javaconfigapplicationcontext">
    <title>
      <classname>JavaConfigApplicationContext</classname>
    </title>

    <para><classname>JavaConfigApplicationContext</classname> provides
    direct access to the beans defined by
    <classname>@Configuration</classname>-annotated classes. For more
    information on the ApplicationContext API in general, please refer to
    the Core Spring documentation. TODO: link to core spring framework
    documentation on ApplicationContext</para>

    <section id="construction-options">
      <title>Construction Options</title>

      <para>Instantiating the
      <classname>JavaConfigApplicationContext</classname> be done by
      supplying <classname>@Configuration</classname>-annotated class
      literals to the constructor, and/or strings representing packages to
      scan for <classname>@Configuration</classname>-annotated
      classes.</para>

      <section>
        <title>Construction by class literal</title>

        <para>Each of the class literals supplied to the constructor will
        be processed, and for each <classname>@Bean</classname>-annotated
        method encountered, JavaConfig will create a bean definition and
        ultimately instantiate and initialize the bean.</para>

        <programlisting>JavaConfigApplicationContext context =
    new JavaConfigApplicationContext(AppConfig.class);
Service service = (Service) context.getBean("serviceA");
</programlisting>

        <programlisting>JavaConfigApplicationContext context =
    new JavaConfigApplicationContext(AppConfig.class, DataConfig.class);
Service service = (Service) context.getBean("serviceA");
</programlisting>
      </section>

      <section>
        <title>Construction by base package</title>

        <para>Base packages will be scanned for the existence of any
        <classname>@Configuration</classname>-annotated classes. Any
        candidate classes will then be processed much as if they had been
        supplied directly as class literals to the constructor.</para>

        <programlisting>JavaConfigApplicationContext context =
    new JavaConfigApplicationContext("**/configuration/**/*.class");
Service service = (Service) context.getBean("serviceA");
</programlisting>

        <programlisting>JavaConfigApplicationContext context =
    new JavaConfigApplicationContext("**/configuration/**/*.class", "**/other/*Config.class);
Service service = (Service) context.getBean("serviceA");
</programlisting>
      </section>

      <section>
        <title>Post-construction configuration</title>

        <para>When one or more classes/packages are used during
        construction, a
        <classname>JavaConfigApplicationContext</classname> cannot be
        further configured. If post-construction configuration is
        preferred or required, use either the no-arg constructor,
        configure by calling setters, then manually refresh the context.
        After the call to <methodname>refresh()</methodname>, the context
        will be 'closed for configuration'.</para>

        <programlisting>JavaConfigApplicationContext context = new JavaConfigApplicationContext();
context.setParent(otherConfig);
context.setConfigClasses(AppConfig.class, DataConfig.class);
context.setBasePackages("**/configuration/**/*.class");
context.refresh();
Service service = (Service) context.getBean("serviceA");
</programlisting>
      </section>
    </section>

    <note>
      <para>Whenever multiple packages and/or classes are used to
      instantiate a <classname>JavaConfigApplicationContext</classname>,
      <emphasis>order matters</emphasis>. This is important when
      considering what happens if two configuration classes define a bean
      with the same name. The last-specified class wins.</para>
    </note>

    <section id="typesafe-getbean">
      <title>Type-safe access to beans</title>

      <para>JavaConfig offers a type-safe mechanism for looking up beans via
      <classname>JavaConfigApplicationContext</classname>:
      <programlisting>JavaConfigApplicationContext context = new JavaConfigApplicationContext(...);
Service service = context.getBean(Service.class);</programlisting>
      If more than one bean of type <interfacename>Service</interfacename> had been defined, the
      above call would throw an exception indicating an ambiguity that the container could not resolve.
      In these cases, the user has a number of options:</para>

      <para>1) Indicate one bean as 'primary'.  Like Spring's XML configuration, JavaConfig allows for
      specifying a given <interfacename>@Bean</interfacename> as 'primary':
      <programlisting>@Configuration
public class MyConfig {
    @Bean(primary=Primary.TRUE)
    public Service myService() {
        return new Service();
    }

    @Bean
    public Service backupService() {
    	return new Service();
    }
}</programlisting>After this modification, all calls to <methodname>getBean(Service.class)</methodname>
        will return the primary bean
      <programlisting>JavaConfigApplicationContext context = new JavaConfigApplicationContext(...);
<lineannotation>// returns the <methodname>myService()</methodname> primary bean</lineannotation>
Service service = context.getBean(Service.class);</programlisting>
</para>

      <para>2) Disambiguate by bean name.  JavaConfig provides a <methodname>getBean()</methodname> variant
      that accepts both a class and a bean name for cases just such as this
      <programlisting>JavaConfigApplicationContext context = new JavaConfigApplicationContext(...);
Service service = context.getBean(Service.class, "myService");</programlisting>
      Because bean ids must be unique, this call guarantees that the ambiguity cannot occur.</para>

      <para>3) Get all matching beans.  It is also reasonable to call the <methodname>getBeansOfType()</methodname>
      method in order to return all beans that implement a given interface:
      <programlisting>JavaConfigApplicationContext context = new JavaConfigApplicationContext(...);
Map matchingBeans = context.getBeansOfType(Service.class);</programlisting>
      Note that this latter approach is actually a feature of the Core Spring Framework's
      <classname>AbstractApplicationContext</classname> (which <classname>JavaConfigApplicationContext</classname> extends)
      and is not type-safe, in that the returned <interfacename>Map</interfacename> is not parameterized.
      </para>
    </section>
  </section>
</chapter>

