<?xml version="1.0" encoding="UTF-8"?>
<chapter id="security">
    <title>Securing your Web services with Spring-WS</title>

    <section id="security-introduction">
        <title>Introduction</title>
        <para>
            In this chapter, we will show you how to add WS-Security aspects to your Web services. We
            will focus on the three different areas of WS-Security, namely:
        </para>
        <formalpara>
            <title>Authentication</title>
            <para>
                This is the process of establishing a <emphasis>principal</emphasis> is who they claim to be.
                In this context, a "principal" generally means a user, device or some other system which can perform an
                action in your application.
            </para>
        </formalpara>
        <formalpara>
            <title>Digital signatures</title>
        </formalpara>
        <formalpara>
            <title>Encryption and Decryption</title>
        </formalpara>
        <para>
            All of these three areas are implemented using the <classname>XwsSecurityInterceptor</classname>, which we
            will describe in <xref linkend="security-xws-security-interceptor"/>
        </para>
<!--        <section>
            <title>Sample SOAP messages</title>
            <para>
                The following SOAP message shows the different aspects of WS-Security.
            </para>
<programlistingco>
    <areaspec>
        <area id="security-msg-security" coords="6" />
        <area id="security-msg-username" coords="7" />
    </areaspec>         
<programlisting><![CDATA[
<SOAP-ENV:Envelope
    xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
 <SOAP-ENV:Header>
  <wsse:Security>
   <wsse:UsernameToken>
    <wsse:Username>Bert</wsse:Username>
    <wsse:Password                
        Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0
        #PasswordText">Ernie</wsse:Password>
   </wsse:UsernameToken>
  </wsse:Security>
 </SOAP-ENV:Header>
 <SOAP-ENV:Body>
  ...
 </SOAP-ENV:Body>
</SOAP-ENV:Envelope>]]>
</programlisting>
<calloutlist>
    <callout arearefs="security-msg-security">
        <para>
            All WS-Security related information is contained in the <literal>Security</literal> header.
        </para>
    </callout>
    <callout arearefs="security-msg-username">
        <para>
            This <literal>UsernameToken</literal> contains the username "Bert" and a plain text password "Ernie".
        </para>            
    </callout>
</calloutlist>
</programlistingco>
        </section>                    
    -->
    </section>
    <section id="security-xws-security-interceptor">
        <title>XwsSecurityInterceptor</title>
        <para>
            The <classname>XwsSecurityInterceptor</classname> is a <classname>EndpointInterceptor</classname> (see <xref
            linkend="ws-endpoint-interceptor"/>) that is based on SUN's XML and Web Services Security package (XWSS).
            This WS-Security implementation is part of the Java Web Services Developer Pack (<ulink
            url="http://java.sun.com/webservices/"><citetitle>Java WSDP</citetitle></ulink>).
        </para>
        <para>
            Like any other endpoint interceptor, it is defined in the endpoint mapping (see <xref
            linkend="ws-endpoint-mapping"/>). This means that you can be selective to adding WS-Security support: some
            endpoint mappings require it, while others do not.
        </para>
        <para>
            The <classname>XwsSecurityInterceptor</classname> requires a <emphasis>security policy file</emphasis> to
            operate. This XML file tells the interceptor what security aspects to require from incoming SOAP messages,
            and what aspects to add to outgoing messages. The format of the policy file will be explained in the
            following sections. You can set the policy with the <methodname>policyConfiguration</methodname> property. 
            The policy file can contain multiple elements, e.g. require a username token on incoming messages, and sign
            all outgoing messages.
        </para>
        <para>
            Additionally, the security interceptor requires one or more <classname>CallbackHandler</classname>s to
            operate. These handlers are used to retrieve certificates, private keys, validate user credentials, etc.
            Spring-WS offers handlers for most common security concerns, e.g. authenticating against a Acegi
            authentication manager, signing outgoing messages based on a X509 certificate. The following sections
            will indicate what callback handler to use for which security concern. You can set the callback handlers
            using the <methodname>callbackHandler</methodname> or <methodname>callbackHandlers</methodname> property.
        </para>
        <para>
            Here is an example that shows how to wire the <classname>XwsSecurityInterceptor</classname> up:
            <programlisting><![CDATA[
<beans>
    <bean id="wsSecurityInterceptor"
        class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor">
        <property name="policyConfiguration" value="classpath:securityPolicy.xml"/>
        <property name="callbackHandlers">
            <list>
                <ref bean="certificateHandler"/>
                <ref bean="authenticationHandler"/>
            </list>
        </property>
    </bean>
    ...
</beans>
]]></programlisting>
            This interceptor is configured using the <filename>securityPolicy.xml</filename> file on the classpath. It
            uses two callback handlers which are defined further on in the file.
        </para>
    </section>
    
    <section>
        <title>Authentication</title>
        <para>
            As stated in the introduction, <emphasis>authentication</emphasis> is the task of determining whether a
            principal is who they claim to be. Within WS-Security, authentication can take two forms: using a username
            and password token (using either a plain text password or a password digest), or using a X509 certificate.
        </para>
        <section>
            <title>Plain Text Username Authentication</title>
            <para>
                The simplest form of username authentication uses <emphasis>plain text passwords</emphasis>. In this
                scenario, the SOAP message will contain a <literal>UsernameToken</literal> element, which itself
                contains a <literal>Username</literal> element and a <literal>Password</literal> element which contains
                the plain text password. Plain text authentication can be compared to the Basic Authentication provided
                by HTTP servers.
            </para>
            <para>
                Note that plain text passwords are not very secure. Therefore, you should always add additional security
                measures to your transport layer if you are using them (using HTTPS instead of plain HTTP, for
                instance).
            </para>
            <para>
                To require that every incoming message contains a <literal>UsernameToken</literal> with a plain
                text password, the security policy file should contain a <literal>RequireUsernameToken</literal>
                element, with the <literal>passwordDigestRequired</literal> attribute set to <literal>false</literal>:
            </para>
            <programlisting><![CDATA[
<xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config">
    ...
    <xwss:RequireUsernameToken passwordDigestRequired="false" nonceRequired="false"/>
    ...
</xwss:SecurityConfiguration>]]></programlisting>
            <para>
                If the username token is not present, the <classname>XwsSecurityInterceptor</classname> will return a
                SOAP Fault to the sender. If it is present, it will fire a
                <classname>PasswordValidationCallback</classname> with a <classname>PlainTextPasswordRequest</classname>
                to the registered handlers. Withing Spring-WS, there are three classes which handle this particular
                callback.
            </para>
            <section id="security-simple-password-validation-callback-handler">
                <title>SimplePasswordValidationCallbackHandler</title>
                <para>
                    The simplest password validation handler is the
                    <classname>SimplePasswordValidationCallbackHandler</classname>. This handler validates passwords
                    agains a in-memory <classname>Properties</classname> object, which you can specify using the
                    <methodname>users</methodname> property, like so:
                </para>
<programlisting><![CDATA[
<bean id="passwordValidationHandler" 
    class="org.springframework.ws.soap.security.xwss.callback.SimplePasswordValidationCallbackHandler">
    <property name="users">
        <props>
            <prop key="Bert">Ernie</prop>
        </props>
    </property>
</bean>]]></programlisting>
                <para>
                    In this case, we are only allowing the user "Bert" to log in using the password "Ernie".
                </para>
            </section>
            <section>
                <title>AcegiPlainTextPasswordValidationCallbackHandler</title>
                <para>
                    The <classname>AcegiPlainTextPasswordValidationCallbackHandler</classname> uses the excellent <ulink
                    url="http://acegisecurity.org/"><citetitle>Acegi Security Framework</citetitle></ulink> to
                    authenticate users. It is beyond the scope of this document to describe Acegi, but suffice it to say
                    that Acegi is a full-fledged security framework. You can read more about Acegi in the <ulink
                    url="http://acegisecurity.org/docbook/acegi.html"><citetitle>Acegi reference
                    documentation</citetitle></ulink>.
                </para>
                <para>
                    The <classname>AcegiPlainTextPasswordValidationCallbackHandler</classname> requires an Acegi
                    <classname>AuthenticationManager</classname> to operate. It uses this manager authenticate against a
                    <classname>UsernamePasswordAuthenticationToken</classname> that it creates. If authentication is
                    succesfull, the token is stored in the <classname>SecurityContextHolder</classname>. You can set the
                    authentication manager using the <methodname>authenticationManager</methodname> property:
                </para>
<programlisting><![CDATA[
<beans>              
  <bean id="acegiHandler" 
      class="org.springframework.ws.soap.security.xwss.callback.acegi.AcegiPlainTextPasswordValidationCallbackHandler">
    <property name="authenticationManager" ref="authenticationManager"/>
  </bean>
  
  <bean id="authenticationManager" class="org.acegisecurity.providers.ProviderManager">
      <property name="providers">
          <bean class="org.acegisecurity.providers.dao.DaoAuthenticationProvider">
              <property name="userDetailsService" ref="userDetailsService"/>
          </bean>
      </property>
  </bean>

  <bean id="userDetailsService" class="com.mycompany.app.dao.UserDetailService" />
  ...
</beans>]]></programlisting>
            </section>
            <section>
                <title>JaasPlainTextPasswordValidationCallbackHandler</title>
                <para>
                    The <classname>JaasPlainTextPasswordValidationCallbackHandler</classname> is based on the standard 
                    <ulink url="http://java.sun.com/products/jaas/"><citetitle>Java Authentication and Authorization 
                    Service</citetitle></ulink>. It is beyond the scope of this document to provide a full 
                    introduction into JAAS, but there is a <ulink 
                    url="http://www.javaworld.com/javaworld/jw-09-2002/jw-0913-jaas.html">
                    <citetitle>good tutorial</citetitle></ulink> available.
                </para>
                <para>
                    The <classname>JaasPlainTextPasswordValidationCallbackHandler</classname> only requires a 
                    <methodname>loginContextName</methodname> to operate. It creates a new JAAS 
                    <classname>LoginContext</classname> using this name, and handles the standard JAAS
                    <classname>NameCallback</classname> and <classname>PasswordCallback</classname> using the username
                    and password provided in the SOAP message. This means that this callback handler 
                    integrates with any JAAS 
                    <classname>LoginModule</classname> that fires these callbacks during the
                    <methodname>login()</methodname> phase, which is standard behavior.
                </para>
                <para>
                    You can wire up a <classname>JaasPlainTextPasswordValidationCallbackHandler</classname> as follows:
                </para>
<programlisting><![CDATA[
<bean id="jaasValidationHandler" 
    class="org.springframework.ws.soap.security.xwss.callback.jaas.JaasPlainTextPasswordValidationCallbackHandler">
    <property name="loginContextName">MyLoginModule</property>
</bean>]]></programlisting>
                <para>
                    In this case, the callback handler uses the <classname>LoginContext</classname> named 
                    "MyLoginModule". This module should be defined in your <filename>jaas.config</filename> file, as 
                    explained in the abovementioned tutorial.
                </para>
            </section>
        </section>

        <section>
            <title>Digest Username Authentication</title>
            <para>
                When using password digests, the SOAP message also contain a <literal>UsernameToken</literal> element,
                which itself contains a <literal>Username</literal> element and a <literal>Password</literal> element.
                The difference is that the password is not sent as plaint text, but as a <emphasis>digest</emphasis>.The
                recipient compares this digest to the digest he calculated from the known password of the user, and if
                they are the same, the user is authenticated. Digest authentication can be compared to the Digest
                Authentication provided by HTTP servers.
            </para>
           <para>
                To require that every incoming message contains a <literal>UsernameToken</literal> element with a
                password digest, the security policy file should contain a <literal>RequireUsernameToken</literal>
                element, with the <literal>passwordDigestRequired</literal> attribute set to <literal>true</literal>.
                Additionally, the <literal>nonceRequired</literal> should be set to <literal>true</literal>:
            </para>
<programlisting><![CDATA[
<xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config">
    ...
    <xwss:RequireUsernameToken passwordDigestRequired="true" nonceRequired="true"/>
    ...
</xwss:SecurityConfiguration>]]></programlisting>
            <para>
                If the username token is not present, the <classname>XwsSecurityInterceptor</classname> will return a
                SOAP Fault to the sender. If it is present, it will fire a
                <classname>PasswordValidationCallback</classname> with a <classname>DigestPasswordRequest</classname>
                to the registered handlers. Withing Spring-WS, there are two classes which handle this particular
                callback.
            </para>
            <section>
                <title>SimplePasswordValidationCallbackHandler</title>
                <para>
                    The <classname>SimplePasswordValidationCallbackHandler</classname> can handle both plain text 
                    passwords as well as password digests. It is described in <xref 
                    linkend="security-simple-password-validation-callback-handler"/>.
                </para>
            </section>
            <section>
                <title>AcegiDigestPasswordValidationCallbackHandler</title>
                <para>
                    The <classname>AcegiPlainTextPasswordValidationCallbackHandler</classname> requires an Acegi
                    <classname>UserDetailService</classname> to operate. It uses this service to retrieve the password
                    of the user specified in the token. The digest of the password contained in this details object is
                    then compared with the digest in the message. If they are equal, the user has succesfully
                    authenticated, and a <classname>UsernamePasswordAuthenticationToken</classname> is stored in the
                    <classname>SecurityContextHolder</classname>. You can set the service using the
                    <methodname>userDetailsService</methodname>. Additionally, you can set a
                    <methodname>userCache</methodname> property, to cache loaded user details.
                </para>
<programlisting><![CDATA[
<beans>
    <bean class="org.springframework.ws.soap.security.xwss.callback.acegi.AcegiDigestPasswordValidationCallbackHandler">
        <property name="userDetailsService" ref="userDetailsService"/>
    </bean>
    
    <bean id="userDetailsService" class="com.mycompany.app.dao.UserDetailService" />
    ...
</beans>]]></programlisting>    
            </section>
        </section>
        
        <section>
            <title>Certificate Authentication</title>
            <para>
                A more secure way of authentication uses X509 certificates. In this scenerario, the SOAP message 
                contains a <literal>BinarySecurityToken</literal>, which contains a Base 64-encoded version of a X509
                certificate. The recipient is used by the recipient to authenticate. The certificate stored in the
                message is also used to sign the message (see <xref linkend="security-verifying-signatures"/>).
            </para>
            <para>
                To make sure that all incoming SOAP messages carry a <literal>BinarySecurityToken</literal>, the 
                security policy file should contain a <literal>RequireSignature</literal> element. This element can
                further carry a <literal>Target</literal> tag, which will be covered in <xref
                linkend="security-verifying-signatures"/>, and a <literal>requireTimeStamp</literal> attribute.
            </para>
<programlisting><![CDATA[
<xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config">
    ...
    <xwss:RequireSignature requireTimestamp="false">
    ...
</xwss:SecurityConfiguration>]]></programlisting>
            <para>
                When a message arrives that carries no certificate, the <classname>XwsSecurityInterceptor</classname> 
                will return a SOAP Fault to the sender. If it is present, it will fire a 
                <classname>CertificateValidationCallback</classname>. There are two handlers within Spring-WS
                which handle this callback for authentication purposes.
            </para>
            <note>
                <para>
                    In most cases, certificate <emphasis>authentication</emphasis> should be preceeded by certificate
                    <emphasis>validation</emphasis>, since you only want authenticate against valid certificates. 
                    Invalid certificates such as certificates for which the expiration date has passed, or which are not
                    in your store of trusted certificates, should be ignored.
                </para>
                <para>
                    In Spring-WS terms, this means that the
                    <classname>AcegiCertificateValidationCallbackHandler</classname> or
                    <classname>JaasCertificateValidationCallbackHandler</classname> should be preceded by
                    <classname>KeyStoreCallbackHandler</classname> (described in <xref
                    linkend="security-key-store-callback-handler"/>). This can be accomplished in the configuration of
                    the <classname>XwsSecurityInterceptor</classname>:
<programlisting><![CDATA[
<bean id="wsSecurityInterceptor"
    class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor">
    <property name="policyConfiguration" value="classpath:securityPolicy.xml"/>
    <property name="callbackHandlers">
        <list>
            <ref bean="keyStoreHandler"/>
            <ref bean="acegiHandler"/>
        </list>
    </property>
</bean>
]]></programlisting>
                    Using this setup, the interceptor will first determine if the certificate in the message is valid
                    using the keystore, and then authenticate against it.
                </para>
            </note>
            <section>
                <title>AcegiCertificateValidationCallbackHandler</title>
                <para>
                    The <classname>AcegiCertificateValidationCallbackHandler</classname> requires an Acegi
                    <classname>AuthenticationManager</classname> to operate. It uses this manager authenticate against a
                    <classname>X509AuthenticationToken</classname> that it creates. The configured authentication
                    manager is expected to supply a provider which can handle this token (usually an instance of
                    <classname>X509AuthenticationProvider</classname>). If authentication is succesfull, the token is
                    stored in the <classname>SecurityContextHolder</classname>. You can set the authentication manager
                    using the <methodname>authenticationManager</methodname> property:
                </para>
<programlisting><![CDATA[
<beans>              
    <bean id="acegiCertificateHandler"
        class="org.springframework.ws.soap.security.xwss.callback.acegi.AcegiCertificateValidationCallbackHandler">
        <property name="authenticationManager" ref="authenticationManager"/>
    </bean>

    <bean id="authenticationManager"
        class="org.acegisecurity.providers.ProviderManager">
        <property name="providers">
            <bean class="org.acegisecurity.providers.x509.X509AuthenticationProvider">
                <property name="x509AuthoritiesPopulator">
                    <bean class="org.acegisecurity.providers.x509.populator.DaoX509AuthoritiesPopulator">
                        <property name="userDetailsService" ref="userDetailsService"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>

  <bean id="userDetailsService" class="com.mycompany.app.dao.UserDetailService" />
  ...
</beans>]]></programlisting>     
                <para>
                    In this case, we are using a custom user details service to obtain authentication details based on
                    the certificate. Refer to the <ulink
                    url="http://acegisecurity.org/docbook/acegi.html"><citetitle>Acegi reference
                    documentation</citetitle></ulink> for more information about authentication against X509
                    certificates.
                </para>
            </section>
            <section>
                <title>JaasCertificateValidationCallbackHandler</title>
                <para>
                    The <classname>JaasCertificateValidationCallbackHandler</classname> requires a 
                    <methodname>loginContextName</methodname> to operate. It creates a new JAAS 
                    <classname>LoginContext</classname> using this name and with the
                    <classname>X500Principal</classname> of the certificate. This means that this callback handler
                    integrates with any JAAS <classname>LoginModule</classname> that handles X500 principals.
                </para>
                <para>
                    You can wire up a <classname>JaasCertificateValidationCallbackHandler</classname> as follows:
                </para>
<programlisting><![CDATA[
<bean id="jaasValidationHandler" 
    class="org.springframework.ws.soap.security.xwss.callback.jaas.JaasCertificateValidationCallbackHandler">
    <property name="loginContextName">MyLoginModule</property>
</bean>]]></programlisting>
                <para>
                    In this case, the callback handler uses the <classname>LoginContext</classname> named 
                    "MyLoginModule". This module should be defined in your <filename>jaas.config</filename> file, and 
                    should be able to authenticate against X500 principals.
                </para>
            </section>
        </section>
            
    </section>
    
    <section>
        <title>Digital Signatures</title>
        
        <section id="security-verifying-signatures">
            <title>Verifying Signatures</title>
            
            <section id="security-key-store-callback-handler">
                <title>KeyStoreCallbackHandler</title>
            </section>
                
        </section>

        <section>
            <title>Signing Messages</title>
        </section>
    </section>

    <section>
        <title>Encryption and Decryption</title>
        
        <section>
            <title>Decryption</title>
        </section>

        <section>
            <title>Encryption</title>
        </section>
        
    </section>
</chapter>
    
