<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;4.&nbsp;Flow execution repositories</title><link rel="stylesheet" href="../styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="Spring Web Flow"><link rel="up" href="index.html" title="Spring Web Flow"><link rel="previous" href="flow-execution.html" title="Chapter&nbsp;3.&nbsp;Flow execution"><link rel="next" href="flow-executor.html" title="Chapter&nbsp;5.&nbsp;Flow executors"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:#31430f;border:none;height:110px;border:1px solid black;"><a style="border:none;background: url();" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/banner4.jpg"></a><a style="border:none;background: url();" href="http://www.interface21.com/" title="Interface21 - Spring from the Source"><img style="border:none;position:absolute;right:32px;" src="images/bannerR.gif"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="flow-execution-repository"></a>Chapter&nbsp;4.&nbsp;Flow execution repositories</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="repository-intro"></a>4.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
			A flow execution represents an executing flow <span class="emphasis"><em>at a point in time</em></span>.
			At runtime there can be any number of flow executions active in parallel.  A single user
			can even have multiple executions active at the same time (for example, when a user is
			operating multiple windows or tabs within their browser).
		</p><p>
			Many of these flow executions span multiple requests into the server and therefore 
			must be saved so they can be resumed on subsequent requests.  This presents technical
			challenges, as there must exist a stable mechanism for a new request to be associated
			with an existing execution in a state that matches what the user expects.  This problem 
			is more difficult when you consider that many applications require use of browser
			navigational buttons and their use involves updating local history without 
			notifying the server.
		</p><p>
			The problem of flow execution persistence is addressed by Spring Web Flow's <span class="emphasis"><em>flow
			execution repository subsystem</em></span>.  In this chapter you will learn how to use the system
			to manage the storage of active web conversations in a stable manner.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="repository-architecture-overview"></a>4.2.&nbsp;Repository architecture overview</h2></div></div><div></div></div><p>
    		Recall the following bullet points noting what happens when a flow execution enters a ViewState:
    	</p><p>
    		</p><div class="orderedlist"><ol type="1"><li><p>
						When a flow execution reaches a <tt class="literal">ViewState</tt> it is said to have <span class="emphasis"><em>paused</em></span>,
						where it waits in that state for user input to be provided so it can continue.  After pausing the 
						<tt class="literal">ViewSelection</tt> returned is used to issue a response to the user
						that provides a vehicle for collecting the required input.
					</p></li><li><p>			
						User input is provided by <span class="emphasis"><em>signaling an event</em></span> that
						<span class="emphasis"><em>resumes</em></span> the flow execution in the paused view state.
						The input event communicates what user action was taken.
					</p></li></ol></div><p>
    	</p><p>
    		Each time an active flow execution is <span class="emphasis"><em>paused</em></span> it is saved out to a 
    		repository.  When the next request comes in for that flow execution, it is restored 
    		from the repository, <span class="emphasis"><em>resumed</em></span>, and continued.  This process continues 
    		until the flow execution reaches an end state, at which it is removed from the repository.
    	</p><p>
    		This process is demonstrated over the next two graphics:
    	</p><div class="mediaobject" align="center"><img src="images/flowexecution-persistence.png" align="middle"><div class="caption"><p>Request one (1) - Paused flow execution persistence</p></div></div><div class="mediaobject" align="center"><img src="images/flowexecution-restoration.png" align="middle"><div class="caption"><p>Request two (2) - Paused flow execution restoration, Removal on end</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="repository-entry-identity"></a>4.3.&nbsp;Flow execution identity</h2></div></div><div></div></div><p>
			When a flow execution is created it marks the start of a new conversation between a browser 
   			and the server.  As outlined, a new flow execution that is still active after startup
   			processing indicates the start of a conversation that will span more than one request
   			and needs to be persisted.  When this is the case, that flow execution is assigned
   			an <span class="emphasis"><em>persistent identifer</em></span> by the repository.  By default the
   			structure of this identifier consists of a two-part composite key.  This key is used
   			by clients to restore the flow execution on subsequent requests.
    	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conversationId"></a>4.3.1.&nbsp;Conversation identifier</h3></div></div><div></div></div><p>
   		 		The first part of a flow execution's persistent identity is a 
   		 		unique <span class="emphasis"><em>conversation identifier</em></span>.  This serves as an index into
   		 		the <span class="emphasis"><em>logical</em></span> conversation between the browser and the server that 
   		 		has just started.
	    	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="continuationId"></a>4.3.2.&nbsp;Continuation identifier</h3></div></div><div></div></div><p>
    			The second part of a flow execution's persistent identity is a <span class="emphasis"><em>continuation identifier</em></span>.
    			This identifier serves as an index into a flow execution representing the state of the conversation 
    			<span class="emphasis"><em>at this point in time</em></span>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="flowExecutionKey"></a>4.3.3.&nbsp;Flow execution key</h3></div></div><div></div></div><p>
    			Together the conversation id plus the continuation id make up the unique two-part
    			<span class="emphasis"><em>flow execution key</em></span> that identifies a state 
    			of a conversation <span class="emphasis"><em>at a point in time</em></span>.  By submitting this key 
    			in a subsequent request a browser can restore the conversation at that point
    			and <span class="emphasis"><em>continue</em></span> from there.
	    	</p></div><p>
    		So on a subsequent request the conversation is resumed by restoring a flow execution
    		from the repository using the two-part key.  After event processing if the 
    		flow execution is still active it is saved back out to the repository.
    		At this time a new flow execution key is generated.  By default that key
    		retains the	same <span class="emphasis"><em>conversation identifier</em></span>, as the same logical 
    		conversation is in progress; however the <span class="emphasis"><em>continuation identifier</em></span>
    		changes to provide an index into the state of the flow execution
    		at <span class="emphasis"><em>this new point in time</em></span>.
    	</p><p>
			By submitting this new key in a subsequent request a browser can
			restore the conversation at that point and <span class="emphasis"><em>continue</em></span> from there.
			This process continues until a flow execution reaches an end state during event processing 
			signaling the end of the conversation.
    	</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conversation-ending"></a>4.4.&nbsp;Conversation ending</h2></div></div><div></div></div><p>
    		When a flow execution reaches an end state it terminates.  If the flow execution was associated 
    		with a logical conversation that spanned more than on request, it is removed from the 
    		repository.  More specifically, the entire conversation is <span class="emphasis"><em>ended</em></span>, 
    		resulting in any flow executions associated with the conversation being purged.
    	</p><p>
    		Once a conversation has been ended the conversation identifier is no longer valid
    		and cannot ever be used again.
    	</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="repository-implementations"></a>4.5.&nbsp;Flow execution repository implementations</h2></div></div><div></div></div><p>
			The next section looks at the repository implementations that are available for use 
			with Spring Web Flow out-of-the-box.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="repository-simple"></a>4.5.1.&nbsp;Default flow execution repository</h3></div></div><div></div></div><p>
				The simplest possible repository and the default implementation.  This repository is stateful,
				managed in the user session, and stores <span class="emphasis"><em>exactly one</em></span> flow
				execution instance per conversation, invalidating it when its end state is reached.
				This repository implementation has been designed with minimal storage overhead in mind.
			</p><p>
				It is important to understand that use of this repository consistently prevents
				duplicate submission when using the back button.  If you attempt to go back
				and resubmit, the continuation id stored in your browser history will not
				match the current continuation id needed to access the flow execution and 
				access will be disallowed.
			</p><p>
				This repository implementation should generally be used when you do not have to
				support browser navigational button use; for example, when you lock down the browser and
				require that all navigation events to be routed through Spring Web Flow.			
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="repository-continuation"></a>4.5.2.&nbsp;Continuation flow execution repository</h3></div></div><div></div></div><p>
				This repository is stateful, managed in the user session, and stores <span class="emphasis"><em>one to many</em></span> flow
				execution instances per conversation, where each flow execution represents a restorable
				state of the conversation at a point in time.  This repository implementation is
				considerably more flexible than simple but incurs more storage overhead.
			</p><p>
 				It is important to understand that use of this repository allows resubmission when
 				using the back button.  If you attempt to go back and resubmit while the conversation
 				is active, the continuation id stored in your browser history will match the
				continuation id of a previous flow execution in the repository.  Access to
				that flow execution representing the state of the conversation at that point in
				time will be granted.
			</p><p>
				Like simple, this repository implementation provides support for <span class="emphasis"><em>conversation
				invalidation after completion</em></span> where once a logical 
				conversation completes (by one of its FlowExecutions reaching an end state),
				the entire conversation is invalidated.  This prevents the possibility of
				resubmission after completion.
			</p><p>
				 This repository is more elaborate than the simple repository, offering
				 more power (by enabling multiple continuations to exist per conversation),
				 but incurring more storage overhead.  This repository implementation should be
				 considered when you do have to support browser navigational button use;
				 for example, you cannot lock down the browser and have 
				 all navigation events to be routed explicitly through Spring Web Flow.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="repository-client"></a>4.5.3.&nbsp;Client continuation flow execution repository</h3></div></div><div></div></div><p>
				This repository is entirely stateless, and its use entails no server-side state.
			</p><p>
				This is achieved by encoding a serialized flow execution directly into the
				flow execution continuation key that is sent in the response.
			</p><p>				
				When asked to load a flow execution by its key on a subsequent request, this
				repository decodes and deserializes the flow execution, restoring it to
				the state it was in when it was serialized.
			</p><p>
 		 		Note this repository implementation by default does not currently support
				<span class="emphasis"><em>conversation invalidation after completion</em></span>, as 
				this capability requires tracking active conversations using some
				form of centralized storage, like a database table.
			</p><p>
				Also note that storing state (a flow execution continuation) on the client
				entails a certain security risk that should be evaluated.
			</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="flow-execution.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="flow-executor.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Flow execution&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;5.&nbsp;Flow executors</td></tr></table></div></body></html>