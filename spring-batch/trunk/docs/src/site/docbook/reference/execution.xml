<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="execution">
  <title>Executing A Job</title>

  <section>
    <title>Introduction</title>

    <para>In Chapter 2, the overall description of the architecture was
    discussed, using the following diagram as a guide:</para>

    <mediaobject>
      <imageobject role="html">
        <imagedata align="center"
                   fileref="images/spring-batch-reference-model.png" />
      </imageobject>

      <imageobject role="fo">
        <imagedata align="center"
                   fileref="src/site/resources/reference/images/spring-batch-reference-model.png" />
      </imageobject>
    </mediaobject>

    <para>When viewed from left to right, the diagram describes a basic flow
    for the execution of a batch job:</para>

    <orderedlist>
      <listitem>
        <para>A Scheduler kicks off a job script (usually some form of shell
        script)</para>
      </listitem>

      <listitem>
        <para>The script sets up the classpath appropriately, and starts the
        Java process. In most cases, using
        <classname>CommandLineJobRunner</classname> as the entry point</para>
      </listitem>

      <listitem>
        <para>The JobRunner finds the <classname>Job</classname> using the
        <classname>JobLocator</classname>, pulls together the
        <classname>JobParameters</classname> and launches the
        <classname>Job</classname></para>
      </listitem>

      <listitem>
        <para>The <classname>JobLauncher</classname> retrieves a
        <classname>JobExecution</classname> from the
        <classname>JobRepository</classname>, and executes the
        <classname>Job</classname></para>
      </listitem>

      <listitem>
        <para>The <classname>Job</classname> executes each
        <classname>Step</classname> in sequence.</para>
      </listitem>

      <listitem>
        <para>The <classname>Step</classname> calls read on the
        <classname>ItemReader</classname>, handing the resulting item to the
        <classname>ItemWriter</classname> until null is returned, periodically
        committing and storing status in the
        <classname>JobRepository</classname>.</para>
      </listitem>

      <listitem>
        <para>When execution is complete, the <classname>Step</classname>
        returns control back to the <classname>Job</classname>, and if no more
        steps exist, control is returned back to the original caller, in this
        case, the scheduler.</para>
      </listitem>
    </orderedlist>

    <para>This flow is perhaps a bit overly simplified, but describes the
    complete flow in the most basic terms. From here, each tier will be
    described in detail, using actual implementations and examples.</para>
  </section>

  <section>
    <title>Run Tier</title>

    <para>As it's name suggests, this tier is entirely concerned with actually
    running the job. Regardless of whether the originator is a Scheduler or an
    HTTP request, a Job must be obtained, parameters must be parsed, and
    eventually a <classname>JobLauncher</classname> called:</para>

    <mediaobject>
      <imageobject role="html">
        <imagedata align="center" fileref="images/run-tier.png" />
      </imageobject>

      <imageobject role="fo">
        <imagedata align="center" fileref="src/site/resources/reference/images/run-tier.png" />
      </imageobject>
    </mediaobject>

    <section>
      <title>Running Jobs from the Command Line</title>

      <para>For users that want to run their jobs from an enterprise
      scheduler, the command line is the primary interface. This is because
      most schedulers (with the exception of Quartz unless using the
      NativeJob) work directly with operating system processes, primarily
      kicked off with shell scripts. There are many ways to launch a Java
      process besides a shell script, such as Perl, Ruby, or even 'build
      tools' such as ant or maven. However, because most people are familiar
      with shell scripts, this example will focus on them.</para>

      <section>
        <title>The CommandLineJobRunner</title>

        <para>Because the script launching the job must kick off a Java
        Virtual Machine, there needs to be a class with a main method to act
        as the primary entry point. Spring Batch provides an implementation
        that serves just this purpose:
        <classname>CommandLineJobRunner</classname>. It's important to note
        that this is just one way to bootstrap your application, but there are
        many ways to launch a Java process, and this class should in no way be
        viewed as definitive. It performs four tasks:</para>

        <itemizedlist>
          <listitem>
            <para>Loads the appropriate Application Context</para>
          </listitem>

          <listitem>
            <para>Parses command line arguments into JobParameters</para>
          </listitem>

          <listitem>
            <para>Locates the appropriate job based on arguments</para>
          </listitem>

          <listitem>
            <para>Uses the JobLauncher provided in the application context to
            launch the job.</para>
          </listitem>
        </itemizedlist>

        <para>All of these tasks are accomplished based completely upon the
        arguments passed in. The following are required arguments:</para>

        <table>
          <title>CommandLineJobRunner arguments</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>jobPath</entry>

                <entry>The location of the XML file that will be used to
                create an <classname>ApplicationContext</classname>. This file
                should contain everything needed to run the complete
                <classname>Job</classname></entry>
              </row>

              <row>
                <entry>jobName</entry>

                <entry>The name of the job to be run.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>These arguments must be passed in with the path first and the
        name second. All arguments after these are considered to be
        JobParameters and must be in the format of 'name=value':</para>

        <screen><prompt>bash$</prompt> java CommandLineJobRunner endOfDayJob.xml endOfDay schedule.date(date)=2008/01/01</screen>

        <para>In most cases you would want to use a manifest to declare your
        main class in a jar, but for simplicity, the class was used directly.
        This example is using the same 'EndOfDay' example from Chapter 2. The
        first argument is 'endOfDayJob.xml', which is the Spring
        <classname>ApplicationContext</classname> containing the Job. The
        second argument, 'endOfDay' represents the job name. The final
        argument, 'schedule.date=01-01-2008' will be converted into
        <classname>JobParameters</classname>. An example of the XML
        configuration is below: </para>

        <programlisting>  &lt;bean id="endOfDay"
        class="org.springframework.batch.core.job.SimpleJob"&gt;
    &lt;property name="steps"&gt;
      &lt;bean id="step1" parent="simpleStep" /&gt;
      &lt;!-- Step details removed for clarity --&gt;
    &lt;/property&gt; 
  &lt;/bean&gt;

  &lt;!-- Launcher details removed for clarity --&gt;
  &lt;bean id="jobLauncher"
        class="org.springframework.batch.core.launch.support.SimpleJobLauncher" /&gt;</programlisting>

        <para>This example is overly simplistic, since there are many more
        requirements to a run a batch job in Spring Batch in general, but it
        serves to show the two main requirements of the
        <classname>CommandLineJobRunner</classname>:
        <classname>Job</classname> and
        <classname>JobLauncher.</classname></para>
      </section>
    </section>
  </section>

  <section>
    <title>Job Tier</title>

    <para>The Job Tier is responsible for the overall execution of a batch
    job. It sequentially executes batch steps, ensuring that all steps are in
    the correct state and all appropriate policies are enforced:</para>

    <mediaobject>
      <imageobject role="html">
        <imagedata align="center" fileref="images/jobTier.png" />
      </imageobject>

      <imageobject role="fo">
        <imagedata align="center" fileref="src/site/resources/reference/images/jobTier.png" />
      </imageobject>
    </mediaobject>

    <para>The job tier is entirely concerned with maintaining the three job
    stereotypes: <classname>Job</classname>,
    <classname>JobInstance</classname>, and
    <classname>JobExecution</classname>. The
    <classname>JobLauncher</classname> interacts with the
    <classname>JobRepository</classname> in order to create a
    <classname>JobExecution</classname>, and the <classname>Job</classname>
    stores the <classname>JobExecution</classname> using the
    repository.</para>

    <section>
      <title>SimpleJobLauncher</title>

      <para>The most basic implementation of the
      <classname>JobLauncher</classname> interface is the SimpleJobLauncher.
      It's only required dependency is a <classname>JobRepository</classname>,
      in order to obtain an execution: </para>

      <programlisting>  &lt;bean id="jobLauncher"
        class="org.springframework.batch.execution.launch.SimpleJobLauncher"&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
  &lt;/bean&gt;</programlisting>

      <para>Once a <classname>JobExecution</classname> is obtained, it is
      passed to the execute method of <classname>Job</classname>, ultimately
      returning the <classname>JobExecution</classname> to the caller:</para>

      <mediaobject>
        <imageobject role="html">
          <imagedata align="center"
                     fileref="images/job-launcher-sequence-sync.png" />
        </imageobject>

        <imageobject role="fo">
          <imagedata align="center"
                     fileref="src/site/resources/reference/images/job-launcher-sequence-sync.png" />
        </imageobject>
      </mediaobject>

      <para>The sequence is fairly straightforward, and works extremely well
      when launched from a scheduler, but causes issues when trying to launch
      from an HTTP request. In this scenario, the launching needs to be done
      asynchronously, so that the <classname>SimpleJobLauncher</classname>
      returns immediately to it's caller. This is because it is not good
      practice to keep an HTTP request open for the amount of time needed by
      long running processes such as batch. An example sequence is below:
      </para>

      <mediaobject>
        <imageobject role="html">
          <imagedata align="center"
                     fileref="images/job-launcher-sequence-async.png" />
        </imageobject>

        <imageobject role="fo">
          <imagedata align="center"
                     fileref="src/site/resources/reference/images/job-launcher-sequence-async.png" />
        </imageobject>
      </mediaobject>

      <para>The <classname>SimpleJobLauncher</classname> can easily be
      configured to allow for this scenario by configuring a
      <classname>TaskExecutor</classname>:</para>

      <programlisting> &lt;bean id="jobLauncher"
        class="org.springframework.batch.execution.launch.SimpleJobLauncher"&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
    &lt;property name="taskExecutor"&gt;
      &lt;bean class="org.springframework.core.task.SimpleAsyncTaskExecutor" /&gt;
    &lt;/property&gt;
  &lt;/bean&gt;</programlisting>

      <para>Any implementation of the spring
      <classname>TaskExecutor</classname> interface can be used to control how
      jobs are asynchronously executed.</para>

      <section>
        <title>Stopping a Job</title>

        <para>One of the most common reasons for wanting to launching a
        <classname>job</classname> asynchronously is to be able to gracefully
        stop it. This can be done through the
        <classname>JobExecution</classname> returned by the
        <classname>JobLauncher</classname>:</para>

        <programlisting>  JobExecution jobExecution = launcher.run(getJob(), jobParameters);

  //give job adequate time to start
  Thread.sleep(1000);

  assertEquals(BatchStatus.STARTED, jobExecution.getStatus());
  assertTrue(jobExecution.isRunning());

  jobExecution.stop();

  //give job time to stop
  Thread.sleep(1000);

  assertEquals(BatchStatus.STOPPED, jobExecution.getStatus());
  assertFalse(jobExecution.isRunning());</programlisting>

        <para>The shutdown is not immediate, since there is no way to force
        immediate shutdown, especially if the execution is currently in
        developer code that the framework has no control over, such as a
        business service. What it does mean, is that as soon as control is
        returned back to the framework, it will set the status of the current
        <classname>StepExecution</classname> to
        <classname>BatchStatus.STOPPED</classname>, save it, then do the same
        for the <classname>JobExecution</classname> before finishing.</para>
      </section>
    </section>

    <section>
      <title>SimpleJobRepository</title>

      <para>The SimpleJobRepository is the only provided implementation of the
      <classname>JobRepository</classname> interface. It completely manages
      the various batch domain objects and ensures they are created and
      persisted correctly. The <classname>SimpleJobRepository</classname> uses
      three different DAO interfaces for the three major domain types it
      stores: <classname>JobInstanceDao</classname>,
      <classname>JobExecutionDao</classname>, and
      <classname>StepExecutionDao</classname>. The repository delegates to
      these DAOs to both persist the various domain objects and query for them
      during initialization. The following configuration shows a
      SimpleJobRepository configured with JDBC DAOs:</para>

      <programlisting>  &lt;bean id="jobRepository" class="org.springframework.batch.core.repository.support.SimpleJobRepository"&gt;
    &lt;constructor-arg ref="jobInstanceDao" /&gt;
    &lt;constructor-arg ref="jobExecutionDao" /&gt;
    &lt;constructor-arg ref="stepExecutionDao" /&gt;
  &lt;/bean&gt;

  &lt;bean id="jobInstanceDao" class="org.springframework.batch.core.repository.support.dao.JdbcJobInstanceDao" &gt;
    &lt;property name="jdbcTemplate" ref="jdbcTemplate" /&gt;
    &lt;property name="jobIncrementer" ref="jobIncrementer" /&gt;
  &lt;/bean&gt;

  &lt;bean id="jobExecutionDao" class="org.springframework.batch.core.repository.support.dao.JdbcJobExecutionDao" &gt;
    &lt;property name="jdbcTemplate" ref="jdbcTemplate" /&gt;
    &lt;property name="jobExecutionIncrementer" ref="jobExecutionIncrementer" /&gt;
  &lt;/bean&gt;

  &lt;bean id="stepExecutionDao" class="org.springframework.batch.core.repository.support.dao.JdbcStepExecutionDao" &gt;
    &lt;property name="jdbcTemplate" ref="jdbcTemplate" /&gt;
    &lt;property name="stepExecutionIncrementer" ref="stepExecutionIncrementer" /&gt;
  &lt;/bean&gt;

  &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate" &gt;
    &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;/bean&gt;</programlisting>

      <para>The configuration above isn't quite complete, each DAO
      implementation is makes a reference to a Spring
      <classname>DataFieldMaxValueIncrementer</classname>.
      <classname>JobInstance</classname>, <classname>JobExecution</classname>,
      and <classname>StepExecution</classname> each have unique IDs, and the
      incrementers are used to create them.</para>

      <section>
        <title>JobRepositoryFactoryBean</title>

        <para>Including the incrementers, which must be database specific, the
        configuration above is verbose. In order to make this more manageable,
        the framework provides a <classname>FactoryBean</classname> for
        convenience: <classname>JobRepositoryFactoryBean</classname>.</para>

        <programlisting>  &lt;bean id="jobRepository"
        class="org.springframework.batch.execution.repository.JobRepositoryFactoryBean"
    &lt;property name="databaseType" value="hsql" /&gt; 
    &lt;property name="dataSource" value="dataSource" /&gt;
  &lt;/bean&gt;</programlisting>

        <para>The databaseType property indicates the type of incrementer that
        must be used. Options include: "db2", "derby", "hsql", "mysql",
        "oracle", and "postgres".</para>
      </section>

      <section>
        <title>In-Memory Repository</title>

        <para>There are scenarios in which you may not want to persist your
        domain objects to the database. One reason may be speed, storing
        domain objects at each commit point takes extra time. Another reason
        may be that you just don't need to persist status for a particular
        job. Spring batch provides a solution:</para>

        <programlisting>  &lt;bean id="jobRepository" class="org.springframework.batch.core.repository.support.SimpleJobRepository"&gt;
    &lt;constructor-arg ref="mapJobInstanceDao" /&gt;
    &lt;constructor-arg ref="mapJobExecutionDao" /&gt;
    &lt;constructor-arg ref="mapJtepExecutionDao" /&gt;
  &lt;/bean&gt;

  &lt;bean id="mapJobInstanceDao"
        class="org.springframework.batch.execution.repository.dao.MapJobInstanceDao" /&gt;

  &lt;bean id="mapJobExecutionDao"
        class="org.springframework.batch.execution.repository.dao.MapJobExecutionDao" /&gt;

  &lt;bean id="mapStepExecutionDao"
        class="org.springframework.batch.execution.repository.dao.MapStepExecutionDao" /&gt;</programlisting>

        <para>The Map* DAO implementations store the batch artifacts in a
        transactional map. So, the repository and DAOs may still be used
        normally, and are transactionally sound, but their contents will be
        lost when the class is destroyed.</para>
      </section>
    </section>

    <section>
      <title>SimpleJob</title>

      <para>The only current implementation of the <classname>Job</classname>
      interface is <classname>SimpleJob</classname>. Since a Job is just a
      simple loop through a list of Steps, this implementation should be
      sufficient for the majority of needs. It has only three required
      dependencies: a name, <classname>JobRepository</classname>, and a list
      of Steps.</para>

      <programlisting>  &lt;bean id="footballJob"
        class="org.springframework.batch.core.job.SimpleJob"&gt;
    &lt;property name="steps"&gt;
      &lt;list&gt;
        &lt;!-- Step Bean details ommitted for clarity --&gt;
        &lt;bean id="playerload" parent="simpleStep" /&gt;
        &lt;bean id="gameLoad" parent="simpleStep" /&gt;
        &lt;bean id="playerSummarization" parent="simpleStep" /&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
  &lt;/bean&gt;</programlisting>

      <para>Each <classname>Step</classname> will be executed in sequence
      until all have completed successfully. Any Step that fails will cause
      the entire job to fail.</para>

      <section>
        <title>Restartability</title>

        <para>One key concern when execution a batch job, is what happens when
        a failed job is restarted? A Job is considered to have been
        'restarted' if the same JobInstance has more than one JobExecution.
        Ideally, all jobs should be able to start up where they left off, but
        there are scenarios where this is not possible. <emphasis
        role="bold">It is entirely up to the developer to ensure that a new
        instance is always created in this scenario</emphasis>. However,
        Spring Batch does provide some help. If a Job should never be
        restarted, but should always be run as part of a new JobInstance, then
        the restartable property may be set to 'false':</para>

        <programlisting>  &lt;bean id="footballJob"
        class="org.springframework.batch.core.job.SimpleJob"&gt;
    &lt;property name="steps"&gt;
      &lt;list&gt;
        &lt;!-- Step Bean details ommitted for clarity --&gt;
        &lt;bean id="playerload" parent="simpleStep" /&gt;
        &lt;bean id="gameLoad" parent="simpleStep" /&gt;
        &lt;bean id="playerSummarization" parent="simpleStep" /&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
    <emphasis role="bold">&lt;property name="restartable" value="false" /&gt;</emphasis>
  &lt;/bean&gt;</programlisting>

        <para>To phrase it another way, setting restartable to false means
        "this Job doesn't not support being started again". Restarting a Job
        that is not restartable will cause a
        <classname>JobRestartException</classname> to be thrown:</para>

        <programlisting>  Job job = new SimpleJob();
  job.setRestartable(false);

  JobParameters jobParameters = new JobParameters();

  JobExecution firstExecution = jobRepository.createJobExecution(job, jobParameters);
  jobRepository.saveOrUpdate(firstExecution);

  try {
    jobRepository.createJobExecution(job, jobParameters);
    fail();
  }
  catch (JobRestartException e) {
    // expected
  }</programlisting>

        <para>This snippet of JUnit code shows how attempting to create a
        <classname>JobExecution</classname> the first time for a non
        restartable <classname>job</classname> will cause no issues. However,
        the second attempt will throw a
        <classname>JobRestartException</classname>.</para>
      </section>

      <section>
        <title>Intercepting Job execution</title>

        <para>During the course of the execution of a
        <classname>Job</classname>, it may be useful to be notified of various
        events in its lifecycle so that custom code may be executed. The
        <classname>SimpleJob</classname> allows for this by calling a
        <classname>JobListener</classname> at the appropriate time:</para>

        <programlisting>  public interface JobListener {

    void beforeJob(JobExecution jobExecution);

    void afterJob(JobExecution jobExecution);

    void onError(JobExecution jobExecution, Throwable e);

    void onInterrupt(JobExecution jobExecution);
  }</programlisting>

        <para>Listeners can be added to a <classname>SimpleJob</classname> via
        the setJobListeners property:</para>

        <programlisting>  &lt;bean id="footballJob"
        class="org.springframework.batch.core.job.SimpleJob"&gt;
    &lt;property name="steps"&gt;
      &lt;list&gt;
        &lt;!-- Step Bean details ommitted for clarity --&gt;
        &lt;bean id="playerload" parent="simpleStep" /&gt;
        &lt;bean id="gameLoad" parent="simpleStep" /&gt;
        &lt;bean id="playerSummarization" parent="simpleStep" /&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
  &lt;property name="jobListeners"&gt;
    &lt;bean class="org.springframework.batch.core.listener.JobListenerSupport" /&gt;
  &lt;/property&gt;
  &lt;/bean&gt;</programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>Application Tier</title>

    <para>The Application tier is entirely concerned with the actual
    processing of input:</para>

    <mediaobject>
      <imageobject role="html">
        <imagedata align="center" fileref="images/application-tier.png" />
      </imageobject>

      <imageobject role="fo">
        <imagedata align="center" fileref="src/site/resources/reference/images/application-tier.png" />
      </imageobject>
    </mediaobject>

    <section>
      <title>ItemOrientedStep</title>

      <para>The figure above shows a simple 'item-oriented' execution flow.
      One item is read in from an <classname>ItemReader</classname>, and then
      handed to an <classname>ItemWriter</classname>, until their are no more
      items left. When processing first begins, a transaction is started and
      periodically committed until the <classname>Step</classname> is
      complete. Given these basic requirements, the
      <classname>ItemOrientedStep</classname> requires the following
      dependencies, at a minimum:</para>

      <itemizedlist>
        <listitem>
          <para><classname>ItemReader</classname> - The
          <classname>ItemReader</classname> that provides items for
          processing.</para>
        </listitem>

        <listitem>
          <para><classname>ItemWriter</classname> - The
          <classname>ItemWriter</classname> that processes the items provided
          by the <classname>ItemReader</classname>.</para>
        </listitem>

        <listitem>
          <para><classname>PlatformTransactionManager</classname> - Spring
          transaction manager that will be used to begin and commit
          transactions during processing.</para>
        </listitem>

        <listitem>
          <para><classname>JobRepository</classname> - The
          <classname>JobRepository</classname> that will be used to
          periodically store the <classname>StepExecution</classname> and
          <classname>ExecutionContext</classname> during processing (just
          before committing).</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>SimpleStepFactoryBean</title>

        <para>Despite the relatively short list of required dependencies for
        an <classname>ItemOrientedStep</classname>, it is an extremely complex
        class that can potentially contain many collaborators. In order to
        ease configuration, a <classname>SimpleStepFactoryBean</classname> can
        be used:</para>

        <programlisting>  &lt;bean id="simpleStep"
        class="org.springframework.batch.core.step.item.SimpleStepFactoryBean" &gt;
    &lt;property name="transactionManager" ref="transactionManager" /&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
    &lt;property name="itemReader" ref="itemReader" /&gt;
    &lt;property name="itemWriter" ref="itemWriter" /&gt;
  &lt;/bean&gt;</programlisting>

        <para>The configuration above represents the only required
        dependencies of the factory bean. Attempting to instantiate a
        <classname>SimpleStepFactoryBean</classname> without at least those
        four dependencies will result in an exception being thrown during
        construction by the Spring container.</para>
      </section>

      <section>
        <title>Configuring a CommitInterval</title>

        <para>As mentioned above, the <classname>ItemOrientedStep</classname>
        reads in and writes out items, periodically commiting using the
        supplied <classname>PlatformTransactionManager</classname>. By
        default, it will commit after each item has been written. This is less
        than ideal in many situations, since beginning and commiting a
        transaction is expensive. Ideally, you would like to process as many
        items as possible in each transaction, which is completely dependant
        upon the type of data being processed and the resources that are being
        interacted with. For this reason, the number of items that are
        processed within a commit can be set as the commit interval:</para>

        <programlisting> &lt;bean id="simpleStep"
        class="org.springframework.batch.core.step.item.SimpleStepFactoryBean" &gt;
    &lt;property name="transactionManager" ref="transactionManager" /&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
    &lt;property name="itemReader" ref="itemReader" /&gt;
    &lt;property name="itemWriter" ref="itemWriter" /&gt;
    <emphasis role="bold">&lt;property name="commitInterval" value="10" /&gt;</emphasis>
  &lt;/bean&gt;</programlisting>

        <para>In this example, 10 items will be processed within each
        transaction. At the beginning of processing a transaction is begun,
        and each time <markup>read</markup> is called on the
        <classname>ItemReader</classname>, a counter is incremented. When it
        reaches 10, the transaction will be committed. This also means that if
        an item is skipped it will still count as an item against the commit
        interval even though it hasn't been written out. (Skipping items will
        be covered in more detail later in this chapter)</para>
      </section>

      <section>
        <title>Configuring a Step for Restart</title>

        <para>Earlier in this chapter, restarting a <classname>Job</classname>
        was discussed. Restart has numerous impacts on steps, and as such may
        require some specific configuration.</para>

        <section>
          <title>Setting a StartLimit</title>

          <para>There are many scenarios where you may want to control the
          number of times a <classname>Step</classname> may be started. An
          example is a <classname>Step</classname> that may be run only once,
          usually because it invalidates some resource that must be fixed
          manually before it can be run again. This is configurable on the
          step level, since different steps have different requirements. One
          Step that may only be executed once can exist as part of the same
          Job as Step that can be run infinitely. Below is an example start
          limit configuration:</para>

          <programlisting> &lt;bean id="simpleStep"
        class="org.springframework.batch.core.step.item.SimpleStepFactoryBean" &gt;
    &lt;property name="transactionManager" ref="transactionManager" /&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
    &lt;property name="itemReader" ref="itemReader" /&gt;
    &lt;property name="itemWriter" ref="itemWriter" /&gt;
    &lt;property name="commitInterval" value="10" /&gt;
    <emphasis role="bold">&lt;property name="startLimit" value="1" /&gt;</emphasis>
  &lt;/bean&gt;</programlisting>

          <para>The simple step above can be run only once. Attempting to run
          it again will cause an exception to be thrown. It should be noted
          that the default value for startLimit is
          <classname>Integer.MAX_VALUE</classname>.</para>
        </section>

        <section>
          <title>Restarting a completed step</title>

          <para>In the case of a restartable job, there may be one or more
          steps that should always be run, regardless of whether or not they
          were successful the first time. An example might be a validation
          step, or a step that cleans up resources before processing. During
          normal processing of a restarted job, any step with a status of
          'COMPLETED', meaning it has already been completed successfully,
          will be skipped. Setting allowStartIfComplete to true overrides this
          so that the step will always run:</para>

          <programlisting> &lt;bean id="simpleStep"
        class="org.springframework.batch.core.step.item.SimpleStepFactoryBean" &gt;
    &lt;property name="transactionManager" ref="transactionManager" /&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
    &lt;property name="itemReader" ref="itemReader" /&gt;
    &lt;property name="itemWriter" ref="itemWriter" /&gt;
    &lt;property name="commitInterval" value="10" /&gt;
    &lt;property name="startLimit" value="1" /&gt;
    <emphasis role="bold">&lt;property name="allowStartIfComplete" value="true" /&gt;</emphasis>
  &lt;/bean&gt;</programlisting>
        </section>

        <section>
          <title>Step restart configuration example</title>

          <programlisting>  &lt;bean id="footballJob"
        class="org.springframework.batch.core.job.SimpleJob"&gt;
    &lt;property name="steps"&gt;
      &lt;list&gt;
        &lt;!-- Step Bean details ommitted for clarity --&gt;
        &lt;bean id="playerload" parent="simpleStep" /&gt;
        &lt;bean id="gameLoad" parent="simpleStep" &gt;
          &lt;property name="allowStartIfComplete" value="true" /&gt;
        &lt;/bean&gt;
        &lt;bean id="playerSummarization" parent="simpleStep" &gt;
          &lt;property name="startLimit" value="2" /&gt;
        &lt;/bean&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
    &lt;property name="restartable" value="true" /&gt;
  &lt;/bean&gt;</programlisting>

          <para>The above example configuration is for a job that loads in
          information about football games and summarizes them. It contains
          three steps: playerLoad, gameLoad, and playerSummarization. The
          playerLoad <classname>Step</classname> loads in player information
          from a flatfile, while the <classname>gameLoad</classname> Step does
          the same for games. The final step, playerSummarization, then
          summarizes the statistics for each player based upon the provided
          games. It is assumed that the file loaded by 'playerLoad' must be
          loaded only once, but that 'gameLoad' will load any games found
          within a particular directory, deleting them after they have been
          successfully loaded into the database. As a result, the playerLoad
          <classname>Step</classname> contains no additionaly configuration.
          It can be started almost limitlessly, and if complete will be
          skipped. The 'gameLoad' <classname>Step</classname>, however, needs
          to be run everytime, in case extra files have been dropped since it
          last executed, so it has 'allowStartIfComplete' set to 'true' in
          order to always be started. (It is assumed that the database tables
          games are loaded into has a process indicator on it, to ensure new
          games can be properly found by the summarization step) The
          summarization <classname>step</classname>, which is the most
          important in the <classname>Job</classname>, is configured to have a
          start limit of 3. This is useful in case it continually fails, a new
          exit code will be returned to the operators that control job
          execution, and it won't be allowed to start again until manual
          intervention has taken place.</para>

          <note>
            <para>This job is purely for example purposes and is not the same
            as the footballJob found in the samples project.</para>
          </note>

          <para>Run 1:</para>

          <orderedlist>
            <listitem>
              <para>playerLoad is executed and completes successfully, adding
              400 players to the 'PLAYERS' table.</para>
            </listitem>

            <listitem>
              <para>gameLoad is executed and processes 11 files worth of game
              data, loading their contents into the 'GAMES' table.</para>
            </listitem>

            <listitem>
              <para>playerSummarization begins processing and fails after 5
              minutes.</para>
            </listitem>
          </orderedlist>

          <para>Run 2:</para>

          <orderedlist>
            <listitem>
              <para>playerLoad is not run, since it has already completed
              succesfully, and allowStartIfComplete is false (the
              default).</para>
            </listitem>

            <listitem>
              <para>gameLoad is executed again and processes another 2 files,
              loading their contents into the 'GAMES' table as well (with a
              process indicator indicating they have yet to be
              processed)</para>
            </listitem>

            <listitem>
              <para>playerSummarization begins processing of all remaining
              game data (filtering using the process indicator) and fails
              again after 30 minutes.</para>
            </listitem>
          </orderedlist>

          <para>Run 3:</para>

          <orderedlist>
            <listitem>
              <para>playerLoad is not run, since it has already completed
              succesfully, and allowStartIfComplete is false (the
              default).</para>
            </listitem>

            <listitem>
              <para>gameLoad is executed again and processes another 2 files,
              loading their contents into the 'GAMES' table as well (with a
              process indicator indicating they have yet to be
              processed)</para>
            </listitem>

            <listitem>
              <para>playerSummarization is not start, and the job is
              immeadiately killed, since this is the third execution of
              playerSummarization, and it's limit is only 2. The limit must
              either be raised, or the <classname>Job</classname> must be
              executed as a new <classname>JobInstance</classname>.</para>
            </listitem>
          </orderedlist>
        </section>
      </section>

      <section>
        <title>Configuring Skip Logic</title>

        <para>There are many scenarios where errors encountered while
        processing should not result in <classname>Step</classname> failure,
        but should be skipped instead. This is usually a decision that must be
        made by someone who understands the data itself and what meaning it
        has. Financial data, for example, may not be skippable because it
        results in money being transferred, which needs to be completely
        accurate. Loading in a list of vendors, on the other hand, might allow
        for skips, since a vendor not being loaded because it was formatted
        incorrectly, or missing necessary information, won't cause issues.
        Usually these bad records are logged as well, which will be covered
        later when discussing listeners. Configuring skip handling requires
        using a new factory bean:
        <classname>SkipLimitStepFactoryBean</classname><programlisting>  &lt;bean id="skipSample" parent="simpleStep"
        class="org.springframework.batch.core.step.item.SkipLimitStepFactoryBean"&gt;
    &lt;property name="skipLimit" value="10" /&gt;
    &lt;property name="itemReader" ref="flatFileItemReader" /&gt;
    &lt;property name="itemWriter" ref="itemWriter" /&gt;
    &lt;property name="skippableExceptionClasses"
              value="org.springframework.batch.item.file.FlatFileParseException"&gt;
    &lt;/property&gt;
  &lt;/bean&gt; </programlisting></para>

        <para>In this example, a <classname>FlatFileItemReader</classname> is
        used, and if at any point a FlatFileParseException is thrown, it will
        be skipped and counted against the total skip limit of 10.</para>
      </section>

      <section>
        <title>Configuring Retry Logic</title>

        <para>In most cases you want an Exception to cause either a skip or
        <classname>Step</classname> failure. However, not all exceptions are
        deterministic. If a FlatFileParseException is encountered while
        reading, it will always be thrown for that record. Resseting the
        <classname>ItmeReader</classname> will not help. However, for other
        exceptions, such as a
        <classname>DeadlockLoserDataAccessException</classname>, which
        indicates that the current process has attempted to update a record
        that another process holds a lock on, waiting and trying again might
        result in success. In this case, a
        <classname>StatefulRetryStepFactoryBean</classname> should be
        used:</para>

        <programlisting>  &lt;bean id="step1" parent="simpleStep"
        class="org.springframework.batch.core.step.item.StatefulRetryStepFactoryBean"&gt;
    &lt;property name="itemReader" ref="itemGenerator" /&gt;
    &lt;property name="itemWriter" ref="itemWriter" /&gt;
    &lt;property name="retryLimit" value="3" /&gt;
    &lt;property name="retryableExceptionClasses" value="org.springframework.dao.DeadlockLoserDataAccessException" /&gt;
  &lt;/bean&gt;</programlisting>

        <para>The StatefulRetryStepFactoryBean requires a limit for the number
        of times an individual item can be retried, and a list of Exceptions
        that are 'retryable'.</para>
      </section>

      <section>
        <title>Intecepting Step Execution</title>

        <para>Just as with the <classname>Job</classname>, there are many
        events during the execution of a <classname>Step</classname> that a
        user may need notification of. For example, if writing out to a flat
        file that requires a footer, the <classname>ItemWriter</classname>
        needs to be notified when the <classname>Step</classname> has been
        completed, so that it can write the footer. This can be accomplished
        with one of many <classname>Step</classname> scoped listeners.</para>

        <section>
          <title>StepListener</title>

          <para>StepListener represents the most generic listener for
          <classname>Step</classname> execution. It allows for notification
          before a Step is started, after it has completed, and if any errors
          are encountered during processing:</para>

          <programlisting>  public interface StepListener extends BatchListener {

    void beforeStep(StepExecution stepExecution);

    ExitStatus onErrorInStep(StepExecution stepExecution, Throwable e);

    ExitStatus afterStep(StepExecution stepExecution);
}</programlisting>

          <para><classname>ExitStatus</classname> is the return type of
          <methodname>onErrorInStep</methodname> and
          <methodname>afterStep</methodname> in order to allow listeners the
          chance to modify the exit code that is returned upon completion of a
          <classname>Step</classname>. A StepListener can be applied to any
          step factory bean via the listeners property:</para>

          <programlisting>  &lt;bean id="simpleStep"
        class="org.springframework.batch.core.step.item.SimpleStepFactoryBean" &gt;
    &lt;property name="transactionManager" ref="transactionManager" /&gt;
    &lt;property name="jobRepository" ref="jobRepository" /&gt;
    &lt;property name="itemReader" ref="itemReader" /&gt;
    &lt;property name="itemWriter" ref="itemWriter" /&gt;
    &lt;property name="commitInterval" value="10" /&gt;
    &lt;property name="listeners" ref="stepListener" /&gt;    
  &lt;/bean&gt;</programlisting>

          <para>Because all listeners extend the
          <classname>BatchListener</classname> interface, they all may be
          applied to factory beans in the same way.</para>
        </section>

        <section>
          <title>ChunkListener</title>

          <para>A chunk is defined as the items processed within the scope of
          a transaction. Committing a transaction commits a 'chunk'. It may be
          useful to be nofied before and after a chunk has completed, in which
          case the <classname>ChunkListener</classname> interface may be
          used:</para>

          <programlisting>  public interface ChunkListener extends BatchListener {

    void beforeChunk();

    void afterChunk();
  }</programlisting>

          <para>The <methodname>beforeChunk</methodname> method is called
          after the transaction is started, but before
          <methodname>read</methodname> is called on the
          <classname>ItemReader</classname>. Conversely,
          <methodname>afterChunk</methodname> is called after the last call to
          <methodname>write</methodname> on the
          <classname>ItemWriter</classname>, but before the chunk has been
          committed.</para>
        </section>

        <section>
          <title>ItemReadListener</title>

          <para>When discussing skip logic earlier, it was mentioned that it
          may be beneficial to log out skipped records, so that they can be
          deal with later. In the case of read errors, this can be done with
          an <classname>ItemReaderListener:</classname><programlisting>  public interface ItemReadListener extends BatchListener {
  
    void beforeRead();

    void afterRead(Object item);
    
    void onReadError(Exception ex);
}</programlisting></para>

          <para>The <methodname>beforeRead</methodname> method will be called
          before each call to <methodname>read</methodname> on the
          <classname>ItemReader</classname>. The
          <methodname>afterRead</methodname> method will be called after each
          successful call to <methodname>read</methodname>, and will be passed
          the item that was read. If there was an error while reading, the
          <classname>onReadError</classname> method will be called. The
          exception encounterd will be provided so that it can be
          logged.</para>
        </section>

        <section>
          <title>ItemWriteListener</title>

          <para>Just as with the ItemReaderListener, the writing of an item
          can be 'listened' to:</para>

          <programlisting>  public interface ItemWriteListener extends BatchListener {

    void beforeWrite(Object item);

    void afterWrite(Object item);

    void onWriteError(Exception ex, Object item);
}</programlisting>

          <para>The <methodname>beforeWrite</methodname> method will be called
          before <methodname>write</methodname> on the
          <classname>ItemWriter</classname>, and is handed the item that will
          be written. The <methodname>afterWrite</methodname> method will be
          called after the item has been succesfully writen. If there was an
          error while writing, the <methodname>onWriteError</methodname>
          method will be called. The exception encountered and the item that
          was attempted to be written will be provided, so that they can be
          logged.</para>
        </section>
      </section>
    </section>

    <section>
      <title>TaskletStep</title>

      <para>ItemOriented processing is not the only way to process in a
      <classname>Step</classname>. What if a <classname>Step</classname> must
      consist as a simple storec procedure call? You could implement the call
      as an <classname>ItemReader</classname> and return null after the
      procedure finishes, but it is a bit unnatural since there would need to
      be a no-op <classname>ItemWriter</classname> and lots of overhead for
      transaction handling, listeners, etc. Spring Batch provides an
      implementation of <classname>Step</classname> for this scenario:
      <classname>TaskletStep</classname>. As explained in Chapter 2, the
      <classname>Tasklet</classname> is a simple interface that has one
      method, <methodname>execute</methodname>, which will be a called once
      for the whole <classname>Step</classname>.
      <classname>Tasklet</classname> implementors might call a stored
      procedure, a script, or a simple SQL upate statement. Because there are
      less concerns, there are only two required dependencies for a
      <classname>TaskletStep</classname>: a <classname>Tasklet</classname>,
      and a <classname>JobRepository</classname>:</para>

      <programlisting>&lt;bean id="taskletStep"
      class="org.springframework.batch.core.step.tasklet.TaskletStep" /&gt;
  &lt;property name="tasklet" ref="tasklet" /&gt;
  &lt;property name="jobRepository" ref="repository" /&gt;
&lt;/bean&gt;
</programlisting>
    </section>
  </section>
</chapter>