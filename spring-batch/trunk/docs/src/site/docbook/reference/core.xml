<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="core">
  <title>Spring Batch Core - the Domain language of Batch</title>

  <section>
    <title>Introduction</title>

    <para>To any experienced batch architect, the overall concepts of batch
    processing described above should be familiar and comfortable. There are
    “Jobs” and “Steps” and a developer supplied processing units called
    ItemReaders and ItemWriters. The following diagram is only a slight
    variation of the batch reference architecture that has been used for
    decades. JCL and COBOL developers are likely to be as comfortable with the
    concepts as C++, C# and Java developers. However, because of the Spring
    patterns, operations, templates, callbacks, and idioms, there are
    opportunities for <itemizedlist>
        <listitem>
          <para>significant improvement in adherence to a clear separation of
          concerns,</para>
        </listitem>

        <listitem>
          <para>clearly delineated architectural layers and services provided
          as interfaces,</para>
        </listitem>

        <listitem>
          <para>simple and default implementations that allowed for quick
          adoption and ease of use out-of-the-box, and</para>
        </listitem>

        <listitem>
          <para>significantly enhanced extensibility.</para>
        </listitem>
      </itemizedlist></para>

    <para>The diagram below provides an overview of the high level components,
    technical services, and basic operations required by a batch architecture.
    This architecture framework is a blueprint that has been proven through
    decades of implementations on the last several generations of platforms
    (COBOL/Mainframe, C++/Unix, and now Java/anywhere). The Simple Batch
    Execution Environment provides a physical implementation of the layers,
    components and technical services commonly found in robust, maintainable
    systems used to address the creation of simple to complex batch
    applications, with the infrastructure and extensions to address very
    complex processing needs. The materials below will walk through the
    details of the diagram.</para>
  </section>

  <section>
    <title id="s.2">Simple Batch Execution Environment high level flow and
    interaction of the architecture.</title>

    <mediaobject>
      <imageobject role="fo">
        <imagedata align="center"
                   fileref="../../resources/reference/images/simple-batch-execution-env.png"
                   format="JPG" />
      </imageobject>

      <imageobject role="html">
        <imagedata align="center"
                   fileref="../../resources/reference/images/simple-batch-execution-env.png"
                   format="JPG" />
      </imageobject>

      <caption><para>Figure 1: Batch Stereotypes</para></caption>
    </mediaobject>

    <para>The application style is organized into four logical tiers, which
    include Run, Job, Application, and Data tiers. The primary goal for
    organizing an application according to the tiers is to embed what is known
    as "separation of concerns" within the system. These tiers can be
    conceptual but may they prove effective in mapping the deployment of the
    artifacts onto physical components like Java runtimes and integration with
    data sources and targets. Effective separation of concerns results in
    reducing the impact of change to the system. The four conceptual tiers
    containing batch artifacts are:</para>

    <para><itemizedlist>
        <listitem>
          <para><emphasis role="bold">Run Tier:</emphasis> The Run Tier is
          concerned with the scheduling and launching of the application. A
          vendor product is typically used in this tier to allow time-based
          and interdependent scheduling of batch jobs as well as providing
          parallel processing capabilities.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Job Tier:</emphasis> The Job Tier is
          responsible for the overall execution of a batch job. It
          sequentially executes batch steps, ensuring that all steps are in
          the correct state and all appropriate policies are enforced.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Application Tier:</emphasis> The
          Application Tier contains components required to execute the
          program. It contains specific tasklets that address the required
          batch functionality and enforces policies around a tasklet execution
          (e.g., commit intervals, capture of statistics, etc.)</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Data Tier:</emphasis> The Data Tier
          provides the integration with the physical data sources that might
          include databases, files, or queues. <emphasis
          role="bold">Note</emphasis> : In some cases the Job tier can be
          completely missing and in other cases one Job Script can start
          several Batch Job instances.</para>
        </listitem>
      </itemizedlist>In addition the components describe the batch interaction
    and services stereotypes that are the domain language and interfaces
    implemented by developers in constructing a batch solution. As the diagram
    illustrates, custom applicaton archifacts, generally created by the
    developer, are the following:</para>

    <itemizedlist>
      <listitem>
        <para>Job Scripts</para>
      </listitem>

      <listitem>
        <para>JobConfigurations</para>
      </listitem>

      <listitem>
        <para>Tasklet</para>
      </listitem>

      <listitem>
        <para>Business Logic</para>
      </listitem>
    </itemizedlist>

    <para>The application architect needs to consider the batch execution
    environment with the following issues:</para>

    <itemizedlist>
      <listitem>
        <para>Define how batch jobs will be launched</para>
      </listitem>

      <listitem>
        <para>Job construction and Configuration</para>
      </listitem>

      <listitem>
        <para>Step construction and Configuration</para>
      </listitem>

      <listitem>
        <para>ItemReaders</para>
      </listitem>

      <listitem>
        <para>ItemWriters</para>
      </listitem>

      <listitem>
        <para>Data Access Strategies</para>
      </listitem>
    </itemizedlist>

    <para>The grey icons indicate the technologies selected as part of the
    batch solution that are not part of the final solution and entail items
    like:</para>

    <itemizedlist>
      <listitem>
        <para>Schedulers (e.g. Quartz, Tivoli, etc.)</para>
      </listitem>

      <listitem>
        <para>Physical Resources in the Data Tier that are the source and
        target of ItemReaders and Writers like Message Queues, Databases,
        Files and Print Queues.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title id="s.2">Job Stereotypes</title>

    <para>This section describes stereotypes relating to the concept of a
    batch job. A job is an entity that encapsulates an entire batch process.
    The file containing the job may sometimes be referred to as the "job
    configuration.</para>

    <section>
      <title id="s.2.1.1">Job</title>

      <para>The job could be described as the heart of the Spring Batch
      framework. It is represented by a Spring bean that implements the
      <emphasis role="bold">Job</emphasis> interface and contains all of the
      information necessary to define the operations performed by a job. A job
      configuration is typically contained within a Spring XML configuration
      file and the job's name is determined by the "id" attribute associated
      with the job configuration bean. The job configuration contains</para>

      <itemizedlist>
        <listitem>
          <para>The simple name of the job</para>
        </listitem>

        <listitem>
          <para>Definition and ordering of [Step Configurations|#Step
          Configuration]</para>
        </listitem>

        <listitem>
          <para>The limit of how many times this job may be started</para>
        </listitem>

        <listitem>
          <para>Whether or not the job is restartable</para>
        </listitem>
      </itemizedlist>

      <para>A default simple implementation of the <emphasis
      role="bold">Job</emphasis> interface is provided by Spring Batch in the
      form of the SimpleJob class which creates some standard functionality on
      top of <emphasis role="bold">Job</emphasis>, namely a standard execution
      logic that all jobs should utilize. In general, all job configurations
      should be defined using a bean of type <emphasis
      role="bold">SimpleJob</emphasis>.</para>
    </section>

    <section>
      <title id="s.2.1.2">Job Instance</title>

      <para>A job instance refers to the business concept of a single job
      invocation. In other words, suppose you have a job called "foo" that is
      run three times a day. There will be one "foo" configuration, and each
      time "foo" is supposed to run would be an instance of the "foo" job.
      Each instance would be uniquely identified as each one represents a
      distinct batch need. Further, each instance might have attempted several
      times to complete its work. Each attempt is represented by a <link
      linkend="s.3.3">JobExecution</link>, described below. A job instance is
      not considered to be complete until an associated job execution
      completes successfully. As such, a single job instance may have many
      executions. To keep track of this, every job instance provides a
      reference to the last execution attempt.</para>

      <para>For example, a unique instance might be identified by just a job
      name, or by the combination of a job name and a scheduled date. Using
      this second type of identification, we might have two distinct
      instances, "foo-01-01-2008" and "foo-01-02-2008." Although these two
      instances would share the same configuration, they would each have their
      own set of executions and the successful completion of one instance
      would not affect the status of the other.</para>

      <para>Job instances are represented by objects of the <emphasis
      role="bold">JobInstance</emphasis> class, which are created when the job
      is executed. Each job instance contains references to related [Step
      Instances|#Step Instance] and a set of job parameters, represented by
      the <emphasis role="bold">JobParameters</emphasis> that uniquely
      identifies this job instance.</para>
    </section>

    <section>
      <title id="s.2.1.3">Job Parameters</title>

      <para>Job Parameters represent parameters to a job that are used to
      either uniquely identify an instance, or to help drive processing. One
      example of identifying a job would be 'Schedule Date'. This is a common
      batch use case where an 'effective date' for the data is used. For
      example, you may be processing on thursday for a scheduled date of
      Monday. Once the JobInstance with a schedule date of monday has
      completed successfully, a schedule date of Tuesday will be used for the
      next run. You will then be given a new JobInstance by the framework,
      since your parameters are different. This allows you to effectively
      control how you define a 'JobInstance', since you control what
      parameters are passed in.</para>
    </section>

    <section>
      <title id="s.2.1.3">Job Execution</title>

      <para>A job execution refers to the technical concept of a single
      attempt to run a job. It is a single attempt to execute the logic
      represented by a job instance. A job execution may end in failure or
      success, but the job instance corresponding to a given execution will
      not be marked as complete unless the execution completes
      successfully.</para>

      <para>For instance, if we have a job instance "foo-01-01-2008" that
      fails to successfully complete its work the first time it is run, when
      we attempt to run it again, a new job execution will be created. If our
      "foo" configuration is restartable, we may begin our second job
      execution from a restart point. Otherwise, our job execution will start
      from the beginning. In either case, we will see that our single job
      instance has had two job executions.</para>

      <para>Job executions are represented by objects of the <emphasis
      role="bold">JobExecution</emphasis> class. These job executions are
      created by an implementation of the <emphasis
      role="bold">JobRepository</emphasis> interface from a given <emphasis
      role="bold">JobInstance</emphasis> corresponding to a unique <emphasis
      role="bold">JobParameters</emphasis> object. Each job execution contains
      a reference to its corresponding job instance and related Step
      Executions.</para>
    </section>
  </section>

  <section>
    <title id="s.2.1">Step Stereotypes</title>

    <para>This section describes stereotypes relating to the concept of a
    batch step. A step is an entity that encapsulates a single, independent
    phase of a batch job. Therefore, every batch job is composed entirely of
    one or more batch steps. Steps should be thought of as unique processing
    streams that will be executed in sequence. For example, if you have one
    step that loads a file into a database, another that reads from the
    database, validates the data, preforms processing, and then writes to
    another table, and another that reads from that table and writes out to a
    file. Each of these steps will be performed completely before moving on to
    the next step. The file will be completely read into the database before
    step 2 can begin.</para>

    <section>
      <title id="s.2.1.1">Step</title>

      <para>A batch step contains all of the information necessary to define a
      discrete set of business logic within a job. This is a necessarily vague
      description because the contents of any given step are at the discretion
      of the developer writing jobs. A step can be as narrowly defined as a
      single line of code or as broadly defined as necessary to complete the
      entire work of your job. There are several factors that will affect the
      breadth of your step configurations.</para>

      <itemizedlist>
        <listitem>
          <para>Re-usability - step definitions can be shared between
          jobs</para>
        </listitem>

        <listitem>
          <para>Transaction Management - depending on your desired transaction
          strategy, you may divide the work of your job differently between
          steps</para>
        </listitem>

        <listitem>
          <para>Extensibility - adequately granular definition of steps allows
          the addition or subtraction of steps at a later time in the
          appropriate position within your job configuration</para>
        </listitem>
      </itemizedlist>

      <para>Steps are defined by instantiating implementations of the
      <emphasis role="bold">Step</emphasis> interface. Two step implementation
      classes are available in the Spring Batch framework, and they are each
      discussed in detail in other sections of this guide. For most
      situations, the <emphasis role="bold">ItemOrientedStep</emphasis>
      implementation is sufficient, but custom control flow behavior and
      transaction management behavior can also be configured by using a
      <emphasis role="bold">RepeatOperationsStep</emphasis>.</para>
    </section>

    <section>
      <title id="s.2.1.3">Step Execution</title>

      <para>A step execution represents the technical concept of a single
      attempt to execute a step. It is a single attempt to execute the logic
      represented by a step instance.</para>

      <para>For instance, if we have a step instance "foo-01-01-2008#step1"
      that fails to successfully complete its work the first time it is run,
      when we attempt to run it again, a new step execution will be created.
      Each of these step executions may represent a different invocation of
      the batch framework, but they will all correspond to the same step
      instance.</para>

      <para>Step executions are represented by objects of the <emphasis
      role="bold">StepExecution</emphasis> class. These step executions are
      created by an implementation of the <emphasis role="bold">Job</emphasis>
      interface from a given <emphasis role="bold">JobExecution</emphasis>.
      Each step execution contains a reference to its corresponding step and
      job execution, and transaction related data such as commit and rollback
      count and start and end times. Additionally, each step execution will
      contain a set of execution attributes, which will contain statistics and
      restart data.</para>
    </section>

    <section>
      <title id="s.2.1.6">Tasklets</title>

      <para>A tasklet represents the execution of a logical unit of work, as
      defined by its implementation of the Spring Batch provided Tasklet
      interface. Tasklets are used when defining step configurations to
      specify the work done by the step. Subsequently, the logic in a tasklet
      is atomic in terms of transactions. A transaction will never commit
      until an entire tasklet execution is complete (unless an exception
      occurs - a transaction might either commit or rollback if that behavior
      is specified in the step's exception management strategy). There is a
      specific implementation of the Step interface, TaskletStep, that works
      directly with a Tasklet.</para>
    </section>
  </section>

  <section>
    <title id="s.5">Item-Oriented Processing Stereotypes</title>

    <para>A powerful batch processing paradigm implemented by the Spring Batch
    framework is the concept of item-oriented processing. That is, doing work
    by defining each unit of work as the operation of retrieving an item from
    input and then processing that item, including any side effects that
    processing might entail, such as file or database operations.</para>

    <section>
      <title id="s.5.1">Reader and Writer Stereotypes</title>

      <para>There are two basic stereotypes that represent the first-class
      participants in item-oriented processing, item providers and item
      processors. They are each represented by a simple interface provided by
      the Spring Batch framework, which allows free reign over their
      implementations and improves our ability to leverage the Spring
      framework's dependency injection capabilities.</para>

      <section>
        <title id="s.5.1.1">Item Readers</title>

        <para>An item reader is an object that is used to retrieve the inputs
        for a step, one at a time. When the item reader has exhausted the
        items it can provide, it will indicate this in a meaningful way
        (generally by returning null). When coupled with an item processor,
        this forms a complete item-oriented process, as each item taken from
        the provider is then processed by the writer.</para>
      </section>

      <section>
        <title id="s.5.1.2">Item Writers/Processors</title>

        <para>An item writer is an object that is used to perform processing
        for a step, one item at a time. Generally, an item writer has no
        knowledge of the input it will receive next, only the item that that
        was passed in its current invocation. As a result, item writers will
        generally make no assumptions about the input they receive an treat
        every item the same way and keep track of its own state between
        invocations. When coupled with an item provider, this forms a complete
        item-oriented process, as each item taken from the provider is then
        processed by the processor.</para>
      </section>
    </section>
  </section>

  <section>
    <title id="s.5.2">Support Stereotypes</title>

    <para>While item readers and writers serve as the main entry points for
    item-oriented processing, they might be supplemented by a number of
    support classes that perform specific tasks within the reader / writer
    lifecycle. These support stereotypes are useful for dividing the work of
    item readers and writers into reusable pieces, as well as abstracting away
    the details of processing, such as interaction with external systems.
    Additionally, they give us another opportunity to leverage the powerful
    configuration features of the Spring framework, as we can switch between
    several beans implementing these support interfaces without changing the
    driving item reader or writer.</para>

    <section>
      <title id="s.2.4.2">Item Transformers</title>

      <para>An item transformer is a class that is capable of taking an object
      and changing it somehow before processing occurs. For instance, an item
      transformer my alter an object by changing its properties or by
      replacing it with another object entirely, such as a wrapper or
      derivative object. It can also be defined as an adaptor, allowing an
      object of one type to be converted for use as an object of a second
      type.</para>
    </section>
  </section>

  <section>
    <title id="s.3">High Level Processing Flow</title>

    <para>The diagram above illustrates the flow and architecture components
    in a typical batch run execution.</para>

    <para>Standard interaction is described as follows:</para>

    <para><emphasis role="bold">1.</emphasis> In the Run tier, a Scheduler
    starts a batch application by invoking a Job Script. The Scheduler
    identifies what batch process it wants to run by passing the name of the
    batch process and any required additional parameters to the Job
    Script.</para>

    <para><emphasis role="bold">2.</emphasis> The Job Script initializes the
    program and executes any job specific scripts prior to calling the Batch
    Launcher.</para>

    <para><emphasis role="bold">3.</emphasis> The Batch Launcher starts the
    Batch Execution Environment based upon any environment settings
    established in the script.</para>

    <para><emphasis role="bold">3.1</emphasis> The Batch Environment starts
    and controls the batch execution. It initializes the Job execution
    environment with static configuration items such as database settings,
    logging levels and creates a Job based on the Job Configuration created by
    a Batch Developer.</para>

    <para><emphasis role="bold">4</emphasis> Based on configuration provided
    by a Batch Developer, the Job sequentially executes steps after checking
    policies to ensure that each step should be started. The status of the Job
    and Step (start time, end time, status such as "started" or "completed" is
    stored at various points during the process. In order to maintain data
    integrity at the application tier, the Step acts as a controller to ensure
    that either an entire group of actions completes successfully or that none
    of the actions completes. In online applications the Unit Of Work and the
    scope of a transaction tend to be the same thing (e.g. update customer).
    This group of actions controlled by a user interaction is referred to as a
    logical unit of work (LUW). However, in batch processing the Step
    frequently separates the transactional scope from the LUW so that many
    LUWs complete within one commit. This greatly improves batch throughput
    (see pseudo code above where REPEAT(size=500). The Step controls the
    overall execution of the Tasklet, ensuring that transactions are committed
    at the appropriate time and that restart and statistics information is
    stored appropriately.</para>

    <para><emphasis role="bold">4.1</emphasis> The first thing the Step is
    responsible for is the initialization of the data required to begin
    processing. The Step will interact with other architecture components,
    such as the Input Source, to setup the data required to be
    processed.</para>

    <para><emphasis role="bold">4.1.1</emphasis> The Input Source provides
    services to access various data sources. It provides location transparency
    to the Batch Tasklet and hides the physical location details of the
    data.</para>

    <para><emphasis role="bold">4.2</emphasis> Once the data is initialized by
    the Input Source, the Step will call into the Tasklet to begin processing.
    The Tasklet contains the business logic to define the LUW and the Step
    repeatedly calls the Tasklets LUW to finish the business function. The
    Step does this by first invoking the execute method on the Tasklet in
    order to acquire a single record/set of data for processing.</para>

    <para><emphasis role="bold">4.2.1</emphasis> Before a record is returned
    to the Tasklet, it may be validated by any number of validation Frameworks
    that can be provided to an input source. A single record/set of data is
    gathered by interacting with the Input Source.</para>

    <para><emphasis role="bold">4.3</emphasis> Once a record/set has been
    obtained, the step calls the tasklet to begin processing.</para>

    <para><emphasis role="bold">4.3.1</emphasis> The Tasklet executes its
    internal business logic by calling other Business Logic components as
    necessary. Based on the business service, it requests or persists objects
    from the data access components.</para>

    <para><emphasis role="bold">4.3.3</emphasis> Data Access components can be
    leveraged retrieve or persist domain objects.</para>

    <para><emphasis role="bold">4.3.4</emphasis> Once the business logic has
    been executed, the resulting output record is written out by utilizing the
    Output Source interface. The Step will repeatedly call steps 4.2 -&gt; 4.3
    for every record provided by the Input Source.</para>

    <para><emphasis role="bold">4.4</emphasis> Once all of the records are
    processed, the Step calls the Tasklet to perform any clean up activities
    such as closing connections, exporting files, etc.</para>

    <para><emphasis role="bold">4.4.1</emphasis> The Step is responsible for
    committing data associated with the remaining logical units of work as
    well as performing any finalization and administrative functions (e.g.
    closing database connections).</para>

    <para>Once the Step has completed finalization the control is passed back
    to the Job, where any necessary logging or clean up is executed for
    application termination and wrap-up -- provided there are no additional
    Steps to execute.</para>
  </section>
</chapter>