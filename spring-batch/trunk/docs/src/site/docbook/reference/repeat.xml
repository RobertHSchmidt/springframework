<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter>
  <title>Repeat</title>

  <section>
    <title>Repeat Template</title>

    <para>Batch processing is about repetitive actions - either as a simple
    optimisation, or as part of a job. To strategise and generalise the
    repetition, and provide what amounts to an iterator framework, Spring
    Batch has the <classname>RepeatOperations</classname> interface. The
    <classname>RepeatOperations</classname> interface looks like this:</para>

    <para><programlisting>public interface RepeatOperations {

    ExitStatus iterate(RepeatCallback callback) throws RepeatException;

}</programlisting>where the callback is a simple interface that allows you to
    insert some business logic to be repeated</para>

    <para><programlisting>public interface RepeatCallback {

    ExitStatus doInIteration(RepeatContext context) throws Exception;

}</programlisting>The callback is executed repeatedly, until the
    implementation decides that the iteration should end. The return value in
    these interfaces is a special form of extendable enumeration (not a true
    enumeration because users are free to create new values). An
    <classname>ExitStatus</classname> is immutable and conveys information to
    the caller of the repeat operations about whether there is any more work
    to do. Generally speaking, implementations of
    <classname>RepeatOperations</classname> should inspect the
    <classname>ExitStatus</classname> and use it as part of the decision to
    end the iteration. Any callback that wishes to signal to the caller that
    there is no more work to do can return
    <code>ExitStatus.FINISHED</code>.</para>

    <para>The simplest general purpose implementation of
    <classname>RepeatOperations</classname> is
    <classname>RepeatTemplate</classname>. It could be used like this</para>

    <programlisting>RepeatTemplate template = new RepeatTemplate();

template.setCompletionPolicy(new FixedChunkSizeCompletionPolicy(2));

template.iterate(new RepeatCallback() {

    public ExitStatus doInIteration(RepeatContext context) {
        // Do stuff in batch...
        return ExitStatus.CONTINUABLE;
    }

});</programlisting>

    <para>In the example we return <code>ExitStatus.CONTINUABLE</code> to show
    that there is more work to do. The callback can also return
    <code>ExitStatus.FINISHED</code> if it wants to signal to the caller that
    there is no more work to do. Some iterations can be terminated by
    considerations intrinsic to the work being done in the callback, others
    are effectively infinite loops as far as the callback is concerned, and
    the completion decision is delegated to an external policy as in the case
    above.</para>

    <section>
      <title>RepeatContext</title>

      <para>The method parameter for the <classname>RepeatCallback</classname>
      is a <classname>RepeatContext</classname>. Many callbacks will simply
      ignore the context, but if necessary it can be used as an attribute bag
      to store transient data for the duration of the iteration. After the
      <methodname>iterate</methodname> method returns, the context will no
      longer exist.</para>

      <para>A <classname>RepeatContext</classname> will have a parent context
      if there is a nested iteration in progress. The parent context is
      occasionally useful for storing data that need to be shared between
      calls to <methodname>iterate</methodname>. This is the case for instance
      if you want to count the number of occurrences of an even in the
      iteration and remember it across subsequent calls.</para>
    </section>
  </section>

  <section>
    <title>Completion Policies</title>

    <para>Inside a <classname>RepeatTemplate</classname> the termination of
    the loop in the <methodname>iterate</methodname> method is determined by a
    <classname>CompletionPolicy</classname> which is also a factory for the
    <classname>ReapeatContext</classname>. The
    <classname>RepeatTemplate</classname> has the reponsibility to use the
    current policy to create a <classname>RepeatContext</classname> and pass
    that in to the <classname>RepeatCallback</classname> at every stage in the
    iteration. After a callback completes its
    <methodname>doInIteration</methodname> the
    <classname>RepeatTemplate</classname> has to make a call to the
    <classname>CompletionPolicy</classname> to ask it to update its state
    (which will be stored in the <classname>RepeatContext</classname>), then
    it asks the policy if the iteration is complete.</para>

    <para>Spring Batch provides some simple general purpose implementations of
    <classname>CompletionPolicy</classname>, for example the
    <classname>SimpleCompletionPolicy</classname> used in the example above.
    The <classname>SimpleCompletionPolicy</classname> just allows an execution
    up to a fixed number of times (with <code>ExitStatus.FINISHED</code>
    forcing early completion at any time).</para>

    <para>Users might need to implement their own completion policies for more
    complicated decisions, e.g. a batch processing window that prevents batch
    jobs from executing once the online systems are in use.</para>
  </section>

  <section>
    <title>Exception Handling</title>

    <para>If there is an exception thrown inside a
    <classname>RepeatCallback</classname>, the
    <classname>RepeatTemplate</classname> consults an
    <classname>ExceptionHandler</classname> which can decide whether or not to
    re-throw the exception. </para>

    <para><programlisting>public interface ExceptionHandler {

    void handleException(RepeatContext context, Throwable throwable)
        throws RuntimeException;

}</programlisting>A common use case is to count the number of exceptions of a
    given type, and fail when a limit is reached. For this purpose Spring
    Batch provides the <classname>SimpleLimitExceptionHandler</classname> and
    slightly more flexible
    <classname>RethrowOnThresholdExceptionHandler</classname>. The
    <classname>SimpleLimitExceptionHandler</classname> has a limit property
    and an exception type that should be compared with the current exception -
    all subclasses of the provided type are also counted. Exceptions of the
    given type are ignored until the limit is reached, and then rethrown.
    Those of other types are always rethrown.</para>

    <para>An important optional property of the
    <classname>SimpleLimitExceptionHandler</classname> is the boolean flag
    <code>useParent</code>. It is false by default, so the limit is only
    accounted for in the current <classname>RepeatContext</classname>. When
    set to true, the limit is kept across sibling contexts in a nested
    iteration (e.g. a set of chunks inside a step).</para>
  </section>

  <section>
    <title>Listeners</title>

    <para>Often it is useful to be able to receive additional callbacks for
    cross cutting concerns across a number of different iterations. For this
    purpose Spring Batch provides the <classname>RepeatListener</classname>
    interface. The <classname>RepeatTemplate</classname> allows users to
    register <classname>RepeatListener</classname>s, and they will be given
    callbacks with the <classname>RepeatContext</classname> and
    <classname>ExitStatus</classname> where available during the
    iteration.</para>

    <para>The interface looks like this:</para>

    <para><programlisting>public interface RepeatListener {
    void before(RepeatContext context);

    void after(RepeatContext context, ExitStatus result);

    void open(RepeatContext context);

    void onError(RepeatContext context, Throwable e);

    void close(RepeatContext context);
}
</programlisting>The <methodname>open</methodname> and
    <methodname>close</methodname> callbacks come before and after the entire
    iteration, and <methodname>before</methodname>,
    <methodname>after</methodname> and <methodname>onError</methodname> apply
    to the individual RepeatCallback calls. </para>

    <para>Note that when there is more than one listener, they are in a list,
    so there is an order. In this case <methodname>open</methodname> and
    <methodname>before</methodname> are called in the same order, and
    <methodname>after</methodname>, <methodname>onError</methodname> and
    <methodname>close</methodname> are called in reverse order.</para>
  </section>

  <section>
    <title>Parallel Processing</title>

    <para>Implementations of <classname>RepeatOperations</classname> are not
    restricted to executing the callback sequentially. It is quite important
    that some implementations are able to execute their callbacks in parallel.
    To this end Spring Batch provides the
    <classname>TaskExecutorRepeatTemplate</classname>, which uses the Spring
    <classname>TaskExecutor</classname> strategy to run the
    <classname>RepeatCallback</classname>. The default is to use a
    SynchronousTaskExecutor, which has the effect of executing the whole
    iteration in the same thread (the same as a normal
    <classname>RepeatTemplate</classname>).</para>
  </section>
</chapter>