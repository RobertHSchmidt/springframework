                                    ------
                                    Spring Batch-Retry Comments
                                    ------
                                    Dave Syer
                                    ------
                                    February 2007

Open Comments and Questions

* Batches and Asynchronous JMS

  There are a large number of common concerns between
  <<<DefaultMessageListenerContainer>>> and <<<RepeatTemplate>>>.  In
  fact one could imagine <<<DefaultMessageListenerContainer>>> being a
  simple example of a batch, something like:

+---
RepeatTemplate template = new RepeatTemplate();

template.setTaskExecutor(new SimpleAsyncTaskExecutor());

template.setTerminationPolicy(new TerminateNeverPolicy());

template.execute(new JmsItemProviderCallback(jmsTemplate));
+---

    * Instead of setting the transactionManager in
    <<<DefaultMessageListenerContainer>>>, wrap the callback in a
    transaction proxy.
  
    * Instead of setting sessionTransacted=true in the
    <<<DefaultMessageListenerContainer>>>, set it on the
    <<<JmsTemplate>>>.

  I think that would give me 80% of the functionality in a
  <<<DefaultMessageListenerContainer>>> without any changes to
  <<<RepeatTemplate>>>.  Maybe the other 20% would be useful additions
  to <<<RepeatTemplate>>> anyway (like being able to stop and start).
  Maybe there is a case for sharing some code, e.g. a base class.
  Maybe the batch project should be an offshoot from the core.task
  package.  It certainly looks like the
  <<<DefaultMessageListenerContainer>>> could be a lot simpler (and
  easier to test), if it delegates transactional properties to
  something not a lot different from a <<<RepeatTemplate>>>.

Resolved

* Using <<<TaskExecutor>>> in Batches

  * What can you do with a <<<RepeatTemplate>>> that you couldn't do with
    a <<<TaskExecutor>>>?  Maybe <<<RepeatTemplate>>> should be a
    <<<TaskExecutor>>>, or use one to execute the batch?  Probably the
    latter would work best, on the basis of preferring composition to
    inheritance generally.

* Asynchronous Batching

  * Can you run a batch asynchronously?  Would need a thread-safe
    <<<RepeatContext>>> that can be shared amongst participating
    threads, and used to determine termination conditions.  

  * If <<<RepeatTemplate>>> used a <<<TaskExecutor>>> to execute its
    tasks, asynchronous batch might be as simple as using an
    asynchronous <<<TaskExecutor>>> internally - the same
    <<<RepeatTemplate>>> would be able to operate in both modes, just
    by changing the <<<TaskExecutor>>>.

* Using RetryContext to Stash State for the Policies

  E.g. in <<<RetryTemplate>>>:

+---
	protected void setupContext(RetryCallback callback, 
        RetryContext context) {

		if (callback instanceof AttributeAccessor) {
			AttributeAccessor accessor = (AttributeAccessor) callback;
			String[] names = accessor.attributeNames();
			for (int i = 0; i < names.length; i++) {
				String name = names[i];
				context.setAttribute(name, accessor.getAttribute(name));
			}
		}
	}

+---

  But this is pants: it makes the callback stateful.  We can't store
  state in the callback to do with the current item becaue the
  callback might (will?) be shared between attempts in a concurrent
  system.

  So what to do?  Nothing - the state for retry is nothing to do with
  the callback, and it is natural to store it in the context.

* Asynchronous Batching - Thread Safe Context

  * What would happen if several threads were sharing a context object
    via a synchronization manager in a thread local (like
    <<<TransactionSynchronizationManager>>>)?  The context itself had
    better be thread safe, otherwise the concurrent peers might assume
    that they have the only copy of the context and try and modify it.


