                                -------------------------------------------------------
                                Implementing Contract-first Web Services with Spring-WS
                                -------------------------------------------------------


Introduction

    This is the second part of a tutorial on how to write contract-first Web services. The first part can be found 
{{{tutorial1.html}here}}. This second part focusses on implementing the Web service contract using Spring Web Services.


Setup

    In this tutorial, we will be using Maven2 to create the initial project structure for us. Doing so is not required, 
but greatly reduces the amount of code we have to write to setup our HolidayService. 

    The following command creates a Maven2 web application project for us, using the Spring-WS archetype (i.e. project 
template):
    
+-------------------------------------
> mvn archetype:create -DarchetypeGroupId=org.springframework.ws \
  -DarchetypeArtifactId=spring-ws-archetype \
  -DarchetypeVersion=1.0-rc1-SNAPSHOT \
  -DgroupId=com.mycompany.hr \
  -DartifactId=holidayService 
+-------------------------------------
    
    This command will create a new directory called <<<holidayService>>>. In this project, there is a 
<<<src/main/webapp>>> directory, which will contain the root of the WAR file. In this directory, you will find 
the standard web application deployment descriptor <<<WEB-INF/web.xml>>>, which basically defines a Spring-WS 
<<<MessageDispatcherServlet>>>, and maps all incoming requests to this servlet:

+-------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
         version="2.4">

    <display-name>MyCompany HR Holiday Service</display-name>

    <servlet>
        <servlet-name>spring-ws</servlet-name>
        <servlet-class>org.springframework.ws.transport.http.MessageDispatcherServlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>spring-ws</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>

</web-app>
+-------------------------------------


    Next to this file, there is <<<WEB-INF/spring-ws-servlet.xml>>>, which is a Spring application context file that
will contain the Spring-WS bean definitions.

Implementing the Endpoint

    In Spring-WS, you will implement <<Endpoints>> to handle incoming XML messages. There are two flavors of endpoints:
{{{http://static.springframework.org/spring-ws/site/apidocs/org/springframework/ws/server/endpoint/MessageEndpoint.html}<<<MessageEndpoints>>>}} and 
{{{http://static.springframework.org/spring-ws/site/apidocs/org/springframework/ws/server/endpoint/PayloadEndpoint.html}<<<PayloadEndpoints>>>}}.
Message endpoint gives access to the entire XML message, including SOAP headers, etc. Typically, however, the 
endpoint will only be interested in the <<payload>> of the message, i.e. the contents of the SOAP body. In that case, 
creating a payload endpoint makes more sense.

* Handling the XML Message
    
    In this sample application, we are going to use {{{http://www.jdom.org}JDom}} to handle XML message. We are also 
using {{{http://www.w3schools.com/xpath/}XPath}}, because it allows us to select particular parts of the XML JDOM tree, 
without requiring strict schema conformance. We extend 
our endpoint from 
{{{http://static.springframework.org/spring-ws/site/apidocs/org/springframework/ws/server/endpoint/AbstractJDomPayloadEndpoint.html}<<<AbstractJDomPayloadEndpoint>>>}}, 
because that will give us a JDOM element to execute the XPath queries on:

+-------------------------------------
package com.mycompany.hr.ws;

import java.text.SimpleDateFormat;
import java.util.Date;

import com.mycompany.hr.service.HumanResourceService;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.Namespace;
import org.jdom.xpath.XPath;
import org.springframework.ws.server.endpoint.AbstractJDomPayloadEndpoint;

public class HolidayEndpoint extends AbstractJDomPayloadEndpoint {

    private XPath startDateExpression;

    private XPath endDateExpression;

    private XPath nameExpression;

    private HumanResourceService humanResourceService;

    public HolidayEndpoint(HumanResourceService humanResourceService) {
        this.humanResourceService = humanResourceService;
    }

    public void init() throws JDOMException {
        Namespace namespace = Namespace.getNamespace("hr", "http://mycompany.com/hr/schemas");
        startDateExpression = XPath.newInstance("//hr:StartDate");
        startDateExpression.addNamespace(namespace);
        endDateExpression = XPath.newInstance("//hr:EndDate");
        endDateExpression.addNamespace(namespace);
        nameExpression = XPath.newInstance("//hr:FirstName|//hr:LastName");
        nameExpression.addNamespace(namespace);
    }

    protected Element invokeInternal(Element holidayRequest) throws Exception {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date startDate = dateFormat.parse(startDateExpression.valueOf(holidayRequest));
        Date endDate = dateFormat.parse(endDateExpression.valueOf(holidayRequest));
        String name = nameExpression.valueOf(holidayRequest);

        humanResourceService.bookHoliday(startDate, endDate, name);
        return null;
    }
}
+-------------------------------------

    Let's go over the class one method at a time. The HolidayEndpoint requires the HumanResourceService business service
to operate, so we use the constructor to inject it. Next, we have the initialization method <<<init>>>, which sets up 
the XPath expressions using the JDOM API. There are three expressions: <<<//hr:StartDate>>> for extracting the 
<<<\<StartDate\>>>> text value, <<<//hr:EndDate>>> for extracting the end date, and <<<//hr:FirstName|//hr:LastName>>> 
for extracting the name of the employee.

    The <<<invokeInternal()>>> method is a template method, which gets passed with the <<<HolidayRequest>>> element 
from the incoming XML message. Next, we use the XPath expressions to extract the String values from the XML messages, 
and convert these values to <<<Dates>>> using a <<<SimpleDateFormat>>>. With these values, we invoke a method on the 
business service. Typically, this will result in result in a database transaction being started, and some records being 
altered in the database. Finally, we return <<<null>>>, which indicates to Spring-WS that we don't want to send a 
response message. If we wanted a response message, we could have returned a JDOM Element that represents the payload
of the response message.

    Using JDOM is just one of the options to handle the XML, other options include DOM, dom4j, XOM, SAX, and StAX, but
also marshalling techniques like JAXB, Castor, XMLBeans, JiBX, and XStream. Refer to the airline sample to see how 
these are used.

    Here's how we would wire up these classes in our <<<spring-ws-servlet.xml>>> application context:
    
+-------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans">

    <bean id="holidayEndpoint" class="com.mycompany.hr.ws.HolidayEndpoint" init-method="init">
        <constructor-arg ref="hrService"/>
    </bean>

    <bean id="hrService" class="com.mycompany.hr.service.StubHumanResourceService"/>

</beans>
+-------------------------------------

* Routing the Message to the Endpoint

    Now that we have written an endpoint that handles the message, we must define how incoming messages are routed to 
that endpoint. In Spring-WS, this is the responsibility of an <<<EndpointMapping>>>. In this tutorial, we will route
messages based on their content, by using a <<<PayloadRootQNameEndpointMapping>>>. Here's how we wire it up in 
<<<spring-ws-servlet.xml>>>:

+-------------------------------------
<bean class="org.springframework.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping">
    <property name="mappings">
        <props>
            <prop key="{http://mycompany.com/hr/schemas}HolidayRequest">holidayEndpoint</prop>
        </props>
    </property>
    <property name="interceptors">
        <bean class="org.springframework.ws.server.endpoint.interceptor.PayloadLoggingInterceptor"/>
    </property>
</bean>
+-------------------------------------
    
    This means that whenever a XML message comes in with the namespace <<<http://mycompany.com/hr/schemas>>> and the 
<<<HolidayRequest>>> local name, it will be routed to the holidayEndpoint. It also adds a <<<PayloadInterceptor>>>, 
which dumps incoming and outgoing messages to the log.

Publishing the WSDL

    Finally, we need to publish the WSDL. As stated on the {{{tutorial1.html}previous page}}, we don't need to write a 
WSDL ourselves; Spring-WS can generate one for us based on some conventions. Here's how we define it:

+-------------------------------------
<bean id="holiday" class="org.springframework.ws.wsdl.wsdl11.DynamicWsdl11Definition">
    <property name="builder">
        <bean class="org.springframework.ws.wsdl.wsdl11.builder.XsdBasedSoap11Wsdl4jDefinitionBuilder">
            <property name="schema" value="/WEB-INF/hr.xsd"/>
            <property name="portTypeName" value="HumanResource"/>
            <property name="locationUri" value="http://localhost:8080/holidayService/"/>
        </bean>
    </property>
</bean>
+-------------------------------------

    The first property we set is the human resource schema we defined on the {{{tutorial1.html}first page}} of this 
tutorial, <<<hr.xsd>>>: we simply placed the schema in the <<<WEB-INF>>> directory of the application. Next, we define 
the WSDL port type to be <<<HumanResource>>>. Finally, we set the location where the service can be reached: 
<<<http://localhost:8080/holidayService>>>.

    If you deploy the application, and point your browser at 
{{{http://localhost:8080/holidayService/holiday.wsdl}<<<http://localhost:8080/holidayService/holiday.wsdl>>>}}, you will
see the generated WSDL. This WSDL is ready to be used by clients, such as {{{http://www.soapui.org/}soapUI}}, or other
SOAP frameworks.

    That concludes this tutorial. The next step would be to look at the echo sample application, that is part of the 
distribution. After that, look at the airline sample, which is a bit more complicated, because it uses JAXB, 
WS-Security, Hibernate, and a transactional service layer. Finally, refer to the {{{http://static.springframework.org/spring-ws/docs/1.0-m3/reference/html/index.html}reference documentation}}.