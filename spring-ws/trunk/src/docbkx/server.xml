<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
                 "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="server">
    <title>Creating a Web service with Spring-WS</title>    
    <section id="ws-introduction">
        <title>Introduction</title>
        <para>
        	Spring Web Services's server-side support in designed around a <classname>MessageDispatcher</classname>
        	that dispatches incoming messages to endpoints, with configurable endpoint mappings, response generation,
        	and endpoint interception.
        	The simplest endpoint is a <interfacename>PayloadEndpoint</interfacename>, just offering a 
        	<literal>Source invoke(Source request)</literal> method. This interface can be implemented for creating an
        	endpoint, but you will prefer the included implementation hierarchy, consisting of, for example
        	<classname>AbstractDomPayloadEndpoint</classname>, <classname>AbstractSaxPayloadEndpoint</classname>, and
        	of course <classname>AbstractMarshallingPayloadEndpoint</classname>. Application endpoints will typically 
        	be subclasses of those.
        	Alternatively, there is a endpoint development that uses Java 5 annotations, such as 
        	<literal>@Endpoint</literal> for marking a POJO as endpoint, and marking a method with 
        	<literal>@PayloadRoot</literal> or <literal>@SoapAction</literal>.
       	</para>
       	<para>
       		Spring-WS's XML handling is extremely flexible. An endpoint can choose from
       		a large amount of XML handling libraries supported by Spring-WS, including the DOM family (W3C DOM, JDOM,
       		dom4j, and XOM), SAX or StAX for faster performance, XPath to extract information from the message, or even
       		<link linkend="oxm">marshalling techniques</link> (JAXB, Castor, XMLBeans, JiBX, or XStream) to convert 
       		the XML to objects and vice-versa.
        </para>
    </section>
    <section>
    	<title>The <classname>MessageDispatcher</classname></title>
    	<para>
    		The server-side of Spring-WS is designed around a central class that dispatches incoming XML messages to 
    		endpoints. Spring-WS's <classname>MessageDispatcher</classname> is extremely flexible, allowing you to 
    		use any sort of class as an endpoint, as long as it can be configured in the Spring IoC container.
    		In a way, the message dispatcher resembles Spring's<classname>DispatcherServlet</classname>, the
    		<quote>Front Controller</quote> used in Spring Web MVC.
    	</para>
    	<para>
    		The processing and dispatching flow of the <classname>MessageDispatcher</classname> is illustrated in the 
    		following sequence diagram.
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="src/docbkx/resources/images/sequence.png" format="PNG" align="center" />
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/sequence.png" format="PNG" align="center" />
				</imageobject>
				<caption>
					<para>The request processing workflow in Spring Web Services</para>
				</caption>
			</mediaobject>
    	</para>
   	    <para>
   	    	When a <classname>MessageDispatcher</classname> is set up for use and a request comes in for that 
   	    	specific dispatcher, said <classname>MessageDispatcher</classname> starts processing the request. The 
   	    	list below describes the complete process a request goes through when handled by a
		    <classname>MessageDispatcher</classname>:
	    </para>
	    <orderedlist>
	        <listitem>
	        	<para>
	        		An appropriate endpoint is searched for. If an endpoint is found, the invocation chain associated
	        		with the handler (preprocessors, postprocessors, and endpoints) will be executed in order to create
	        		a response.
	        	</para>
	        </listitem>
	        <listitem>
	        	<para>
	        		An appropriate adapter is searched for the endpoint. The <classname>MessageDispatcher</classname>
	        		delegates to this adapter to invoke the endpoint.
	        	</para>
        	</listitem>
	        <listitem>
	        	<para>
	        		If a response is returned, it is sent on its way. If no response is returned (which could be due to
	        		a pre- or postprocessor intercepting the request, for example, for security reasons), no response is
	        		sent.
	        	</para>
	        </listitem>
	    </orderedlist>
        <para>
        	Exceptions that are thrown during handling of the request get picked up by any of the endpoint exception 
        	resolvers that are declared in the application context. Using these exception resolvers allows you to define
        	custom behaviors in case such exceptions get thrown, such as return a SOAP Fault.
       	</para>
    	<para>
    		The <classname>MessageDispatcher</classname> has several properties, for setting endpoint adapters, 
    		<link linkend="server-endpoint-mapping">mappings</link>,  
    		<link linkend="server-endpoint-exception-resolver">exception resolvers</link>.
    		However, setting these properties is not required, since the dispatcher will automatically detect all of 
    		these types that are registered in the application context. Only when detection needs to be overriden, 
    		should these properties be set.
   		</para>
   		<para>
   			The message dispatcher operates on a <link linkend="message-context">message context</link>, and not 
   			transport-specific input stream and output stream. As a result, transport specific requests need to read 
   			into a <interfacename>MessageContext</interfacename>. For HTTP, this is done with a 
   			<classname>WebServiceMessageReceiverHandlerAdapter</classname>, which is a Spring Web 
   			<interfacename>HandlerInterceptor</interfacename>, so that the <classname>MessageDispatcher</classname>
   			can be wired in a standard <classname>DispatcherServlet</classname>. There is a more convenient way to do
   			this, however, which is shown in the next section.
   		</para>
		<section>
			<title><classname>MessageDispatcherServlet</classname></title>
			<para>
				The <classname>MessageDispatcherServlet</classname> is a standard <interface>Servlet</interface> which 
				conveniently extends from the standard Spring Web <classname>DispatcherServlet</classname>, and wraps
				a <classname>MessageDispatcher</classname>.  As such, it combines the attributes of these into one:
				as a <classname>MessageDispatcher</classname>, if follows the same request handling flow as described
				in the previous section.
				As a servlet, the 
				<classname>MessageDispatcherServlet</classname> is configured in the <filename>web.xml</filename> of 
				your web application. Requests that you want the <classname>MessageDispatcherServlet</classname> to 
				handle will have to be mapped using a URL mapping in the same <literal>web.xml</literal> file. This is 
				standard Java EE servlet configuration; an example of such a 
				<classname>MessageDispatcherServlet</classname> declaration and mapping can be found below.
			</para>
		    <programlisting><![CDATA[<web-app>

    <servlet>
        <servlet-name>spring-ws</servlet-name>
        <servlet-class>org.springframework.ws.transport.http.MessageDispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>spring-ws</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>

</web-app>]]></programlisting>
    		<para>
    			In the example above, all requests will be handled by the <literal>'spring-ws'</literal>
			    <classname>MessageDispatcherServlet</classname>. This is only the first step in setting up Spring Web 
			    Services; the various endpoint and other beans used by the Spring Web Services framework also need to be
			    configured.
		    </para>
	        <para>
	        	Because the <classname>MessageDispatcherServlet</classname> is a standard Spring 
	        	<classname>DispatcherServlet</classname>, it will <emphasis>look for a file named 
	        	<literal>[servlet-name]-servlet.xml</literal></emphasis> in the <literal>WEB-INF</literal> directory
	        	of your web application and create the beans defined there.
	        	In the example above, that means that it looks for <filename>spring-ws-servlet.xml</filename>.
	        </para>
		</section>
   	</section>
    <section>
        <title>Endpoints</title>
        <para>
        	Endpoints are the central concept in Spring-WS's server-side support. Endpoints provide access to the 
        	application behavior which is typically defined by a business service interface. Endpoint interpret the XML
        	request message and uses that input to invoke a method on the business service. The result of that service 
        	invocation is represented as a response message. Spring-WS has a wide variety of endpoints, using various
        	ways to handle the XML message, and to create a response.
       	</para>
        <para>
        	The basis for most endpoint in Spring Web Services is the 
        	<interfacename>org.springframework.ws.server.endpoint.PayloadEndpoint</interfacename> interface, the source
        	code of which is listed below.
        </para>
        <programlisting><![CDATA[public interface PayloadEndpoint {

    /**
     * Invokes an operation.
     */
    Source invoke(Source request) throws Exception;
}]]></programlisting>
		<para>
			As you can see, the <interfacename>PayloadEndpoint</interfacename> interface defines a single method that 
			is invoked with the XML payload of a request (typically the contents of the SOAP Body, see 
			<xref linkend="soap-message"/>). The returned <interface>Source</interface>, if any, is stored in the 
			response XML message. While the <interfacename>PayloadEndpoint</interfacename> interface is quite abstract,
		    Spring-WS offers a lot of endpoint implementations out of the box that already contain a lot of the 
		    functionality you might need. The <interfacename>PayloadEndpoint</interfacename> interface just defines the 
		    most basic responsibility required of every endpoint; namely handling a request and returning a response.
	    </para>
	    <para>
	    	Alternatively, there is the <interfacename>MessageEndpoint</interfacename>, which operated on a 
	    	whole <link linkend="message-context"><interfacename>MessageContext</interfacename></link> rather than just
	    	the payload. Typically, your code should only not be dependent on messages, because the payload should 
	    	contain the interesting information. Only when it is necessary to perform actions on the mesage a whole, 
	    	such as adding a SOAP header, get an attachment, etc., should you need to cast to implement 
	    	<interfacename>MessageEndpoint</interfacename>, though these actions are usually performed in a 
	    	<link linkend="server-endpoint-interceptor">endpoint interceptor</link>.
	    </para>
	    <section>
	    	<title><classname>AbstractDomPayloadEndpoint</classname> and other DOM endpoints</title>
	    	<para>
	    		One of the most basic ways to handle the incoming XML payload is by using a DOM (Document Object Model)
	    		API. By extending from <classname>AbstractDomPayloadEndpoint</classname>, you can use the 
	    		<package>org.w3c.dom.Element</package> and related classes to handle the request, and create the 
	    		response. When using the <classname>AbstractDomPayloadEndpoint</classname> as the baseclass for your 
	    		endpoints you only have to override the <methodname>invokeInternal(Element, Document)</methodname>
	    		method, implement your logic, and return an <interfacename>Element</interfacename>. Here is a short
	    		example consisting of a class and a declaration in the application context.
	    	</para>
	    	<programlisting><![CDATA[
public class SampleEndpoint extends AbstractDomPayloadEndpoint {

    private String responseText;
	
    public SampleEndpoint(String responseText) {
        this.responseText = responseText;
    }

    protected Element invokeInternal(
	    	Element requestElement,
	    	Document document) throws Exception {
    	String requestText = requestElement.getTextContext();
    	System.out.println("Request text: " + requestText);

        Element responseElement = document.createElement("response");
        responseElement.setTextContent(responseText);
        return responseElement;
    }
}]]></programlisting>
   			<programlisting><![CDATA[<bean id="sampleEndpoint" class="samples.SampleEndpoint">
  	<constructor-arg value="Hello World!"/>
</bean>]]></programlisting>
			<para>
				The above class and the declaration in the application context is all you need besides setting up a 
				endpoint mapping (see the section entitled <xref linkend="server-endpoint-mapping" />) to get this very
				simple endpoint working.
			</para>
			<para>
				Besides the <classname>AbstractDomPayloadEndpoint</classname>, which uses W3C DOM, there are other 
				base classes which use alternative DOM APIs. Spring Web Services supports most DOM APIs, so that you 
				can use the one you are familiar with. For instance, the 
				<classname>AbstractJDomPayloadEndpoint</classname> allows you to use JDOM, and the 
				<classname>AbstractXomPayloadEndpoint</classname> uses XOM to handle the XML. All endpoints have an 
				<methodname>invokeInternal</methodname> method similar to above.
			</para>
	    </section>
	    <section>
	    	<title><classname>AbstractMarshallingPayloadEndpoint</classname></title>
	    	<para/>
	    </section>
	    <section>
	    	<title><literal>@Endpoint</literal></title>
	    	<para/>
	    </section>
    </section>
    <section id="server-endpoint-mapping">
        <title>Endpoint mappings</title>
        <para>
            The endpoint mapping is responsible for mapping incoming messages to appropriate endpoints. It does this by
            delivering a <classname>EndpointInterceptorChain</classname>, which consists of the endpoint that matches
            the incoming request, and an optional list of endpoint interceptors. When a message is received by the
            <classname>MessageDispatcher</classname>, it will ask the registered endpoint mappings to come up with a
            appropriate <classname>HandlerExecutionChain</classname>. After that, the
            <classname>MessageDispatcher</classname> will invoke the endpoint and interceptors in the chain.
        </para>
        <para>
            Most endpoint mappings inherit from the <classname>AbstractEndpointMapping</classname>, which offers the
            following properties:
            <informaltable>
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>
                                <methodname>interceptors</methodname>
                            </entry>
                            <entry>
                                the list of interceptors use. <interfacename>EndpointInterceptor</interfacename>s are
                                discussed in <xref linkend="ws-endpoint-interceptor"/>.
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <methodname>defaultHandler</methodname>
                            </entry>
                            <entry>
                                the default handler to use. This endpoint will be returned if no specific mapping was
                                found.
                            </entry>
                        </row>
                        <row>
                            <entry>
                                
                            </entry>
                        </row>

                    </tbody>
        </tgroup>
        </informaltable>
        </para>
        <section>
            <title>SoapActionEndpointMapping</title>
            <para/>
        </section>
        <section>
            <title>PayloadRootQNameEndpointMapping</title>
            <para/>
        </section>
        <section id="server-endpoint-interceptor">
            <title>Adding <interfacename>EndpointInterceptors</interfacename></title>
            <para/>
        </section>
        <section id="server-endpoint-exception-resolver">
            <title>Handling Exceptions</title>
            <para>
                Spring-WS provides
                <classname>EndpointExceptionResolvers</classname>
                to ease the pain of unexpected
                exceptions occurring while your message is being processed by an endpoint which matched the request.
                <classname>EndpointExceptionResolver</classname>
                s somewhat resemble the exception mappings that can be
                defined in the web application descriptor
                <filename>web.xml</filename>
                .
                Rather than expose the innards of your application by giving a client a full stack trace, you can handle
                the exception any way you want, e.g. return a SOAP fault with a specific fault code and string.
                Furthermore, a programmatic way of handling exceptions gives you many more options for how to respond
                appropriately.
            </para>
            <para>
                Besides implementing the
                <classname>HandlerExceptionResolver</classname>
                interface, which is only a
                matter of implementing the
                <methodname>resolveException(MessageContext, endpoint, Exception)</methodname>
                method and returning a
                boolean, you may also use the
                <classname>SoapFaultMappingExceptionResolver</classname>
                .
                This resolver enables you to take the class name of any exception that might be thrown and map it to a
                SOAP Fault, like so:
                <programlisting><![CDATA[
<bean id="exceptionResolver"
    class="org.springframework.ws.soap.endpoint.SoapFaultMappingExceptionResolver">
    <property name="defaultFault" value="RECEIVER,Server error">
    </property>
    <property name="exceptionMappings">
        <props>
            <prop key="org.springframework.oxm.ValidationFailureException">
                SENDER,Invalid request
            </prop>
        </props>
    </property>
</bean>
]]></programlisting>
                This configuration will map exceptions of type
                <classname>ValidationFailureException</classname>
                to a
                sender side SOAP Fault with a fault string "Invalid request".
                If any other exception occurs, it will return the default fault: a server side fault with fault string
                "Server error".
                Refer to the Javadoc of
                <classname>SoapFaultDefinitionEditor</classname>
                to read more about the exact
                notation of the faults.
            </para>
        </section>
        </section>

    <section>
        <title>Similarities between Spring-MVC and Spring-WS</title>
        <para>
            Spring-WS has the same basic architecture as Spring's Web MVC framework.
            The table below shows some of the core concepts of Spring Web MVC, and the corresponding class in Spring-WS.
            <informaltable>
                <tgroup cols="2">
                    <thead>
                        <row>
                            <entry>Spring Web MVC</entry>
                            <entry>Spring Web Services</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <classname>DispatcherServlet</classname>
                            </entry>
                            <entry>
                                <classname>MessageDispatcher</classname>
                            </entry>
                        </row>
                        <row>
                            <entry>handler</entry>
                            <entry>endpoint</entry>
                        </row>
                        <row>
                            <entry>
                                <classname>HandlerAdapter</classname>
                            </entry>
                            <entry>
                                <classname>EndpointAdapter</classname>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <classname>HandlerMapping</classname>
                            </entry>
                            <entry>
                                <classname>EndpointMapping</classname>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <classname>HandlerInterceptor</classname>
                            </entry>
                            <entry>
                                <classname>EndpointInterceptor</classname>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <classname>HandlerExceptionResolver</classname>
                            </entry>
                            <entry>
                                <classname>EndpointExceptionResolver</classname>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
        </para>
    </section>
</chapter>